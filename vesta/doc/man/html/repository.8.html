<!-- This file generated automatically by mtex2html(1) -->
<HTML>

<HEAD>
<TITLE>repository - Vesta repository server</TITLE>
</HEAD>

<BODY BGCOLOR="#ffffff" VLINK="#006633">
<H2>repository(8)</H2>

<H3>Name</H3>
<BLOCKQUOTE>
<P>

<B>repository</B> - Vesta repository server
</BLOCKQUOTE>

<H3>Synopsis</H3>
<BLOCKQUOTE>
<P>

<B>repository</B> [<A HREF="repository.8.html#-h">-h</A>] [<A HREF="repository.8.html#-d">-d <I>level</I></A>] [<A HREF="repository.8.html#-f">-f <I>first-ckp</I></A>] [<A HREF="repository.8.html#-D">-D <I>dump-file-name</I></A>]<P>

In the most common usage, all arguments are defaulted.
</BLOCKQUOTE>

<H3><A NAME="Contents">Contents</A></H3>
<BLOCKQUOTE>
<P>

<UL>
<LI> <A HREF="repository.8.html#Description">Description</A>
<LI> <A HREF="repository.8.html#NFSInterface">NFS Interface</A>
<LI> <A HREF="repository.8.html#SRPCInterface">SRPC Interface</A>
<LI> <A HREF="repository.8.html#AccessControl">Access Control</A>
<UL>
<LI> <A HREF="repository.8.html#Principal identification and authentication">Principal identification and authentication</A>
<LI> <A HREF="repository.8.html#Access controls">Access controls</A>
<LI> <A HREF="repository.8.html#Access checking">Access checking</A>
<LI> <A HREF="repository.8.html#Export file">Export file</A>
<LI> <A HREF="repository.8.html#Group file">Group file</A>
<LI> <A HREF="repository.8.html#Aliases and the alias file">Aliases and the alias file</A>
<LI> <A HREF="repository.8.html#Limitations">Limitations</A>
</UL>
<LI> <A HREF="repository.8.html#Performance Tuning">Performance Tuning</A>
<UL>
<LI> <A HREF="repository.8.html#File Descriptor Caching">File Descriptor Caching</A>
<LI> <A HREF="repository.8.html#File Descriptor Cache Locking">File Descriptor Cache Locking</A>
<LI> <A HREF="repository.8.html#NFS Threads">NFS Threads</A>
<LI> <A HREF="repository.8.html#NFS Buffering">NFS Buffering</A>
<LI> <A HREF="repository.8.html#NFS Duplicate Suppression">NFS Duplicate Suppression</A>
<LI> <A HREF="repository.8.html#NFS Duplicate Suppression Locking">NFS Duplicate Suppression Locking</A>
<LI> <A HREF="repository.8.html#Copy-on-Write Limits">Copy-on-Write Limits</A>
<LI> <A HREF="repository.8.html#SRPC Threads">SRPC Threads</A>
<LI> <A HREF="repository.8.html#SRPC Timeouts">SRPC Timeouts</A>
</UL>
<LI> <A HREF="repository.8.html#Flags">Flags</A>
<LI> <A HREF="repository.8.html#Weeding Hooks">Weeding Hooks</A>
<LI> <A HREF="repository.8.html#Configuration">Configuration</A>
<LI> <A HREF="repository.8.html#See_Also">See Also</A>
<LI> <A HREF="repository.8.html#Author">Author</A>
</UL>
<P>

</BLOCKQUOTE>

<H3><A NAME="Description">Description</A></H3>
<BLOCKQUOTE>
<P>

See the <A HREF="vesta-intro.1.html#Terminology">Terminology</A> section
of the <A HREF="vesta-intro.1.html">vesta-intro</A> man page
for definitions of terms.<P>

The <B>repository</B> program is the Vesta repository server.  It
provides stable storage for immutable, versioned Vesta sources in
a tree of <I>appendable and immutable directories</I>,
for working sources that are still being
edited in a tree of <I>mutable directories</I>, and for Vesta <I>derived files</I>.
The server also provides a tree of <I>volatile directories</I>, which allow tools
started by the evaluator to view Vesta bindings as
filesystem directories, with the changes the tools make recorded by
the repository and available to the evaluator.
</BLOCKQUOTE>

<H3><A NAME="NFSInterface">NFS Interface</A></H3>
<BLOCKQUOTE>
<P>

The repository's NFS interface makes the trees of appendable and immutable,
mutable, and volatile directories visible as a part of the ordinary file system
name space.  The appendable/immutable tree is conventionally mounted under
<TT>/vesta</TT>, the mutable tree under <TT>/vesta-work</TT>, and the volatile
tree under <TT>/vesta-work/.volatile</TT>.  These
names can be customized with the <I>[UserInterface]AppendableRootName</I> and
<I>[UserInterface]MutableRootName</I> settings in the
Vesta configuration file (vesta.cfg).<P>

The NFS interface provides a mildly distorted view of the repository's
contents.  All types of Vesta directories are
manifested as NFS directories, and both mutable and immutable files
are manifested as NFS files.  Stubs and ghosts are normally manifested
as empty files with unusual access permissions.  On a master stub, the
read and execute permissions are turned off, but the setuid bit is
turned on.  The write permissions are meaningful, so they are allowed
to show through.  Thus a master stub will typically appear in an "ls
-l" listing with mode <TT>--wS------</TT> or <TT>--wS-w----</TT>.  On a
non-master stub, all permissions are turned off, but the setgid bit is
turned on, so "ls -l" will show <TT>------S---</TT>.  On a ghost, all
permissions are turned off, but the sticky bit is turned on, so "ls
-l" will show <TT>---------T</TT>.  <P>

Exception: If a stub or ghost has a nonempty value for its
<TT>symlink-to</TT> attribute, it is manifested as a symbolic link.  The
attribute should have a singleton value; the results are unspecified
if it is multivalued.  Normally, the attribute's value gives the
symlink's value.  However, if the attribute's value is the special
token "$LAST", the symlink's value is the arc in the current directory
that consists entirely of decimal digits, has no extra leading zeroes, is
not bound to a ghost or stub, and has the largest numeric value of all
such arcs.  If there are no such arcs, the value is -1.<P>

The NFS interface is exported on a nonstandard UDP port and is not
registered with the portmapper or mount daemon.  Instead, the host and
port number must be obtained from the Vesta configuration file,
settings <I>NFS_host</I> and <I>NFS_port</I> in the <I>[Repository]</I> section.
A special program <A HREF="vmount.8.html"><B>vmount</B>(8)</A> is available for
mounting the repository.  A pair of shell scripts provides a more
convenient front-end to this program; see
<A HREF="mountrepos.8.html"><B>mountrepos</B>(8)</A>, and
<A HREF="umountrepos.8.html"><B>umountrepos</B>(8)</A>.
</BLOCKQUOTE>

<H3><A NAME="SRPCInterface">SRPC Interface</A></H3>
<BLOCKQUOTE>
<P>

The repository also has a remote procedure call interface.  This
interface provides access to functions that do not map naturally onto
the NFS interface, such as atomic checkin/checkout of packages,
replication, etc.  The interface is implemented using the
Vesta-specific SRPC (simple remote procedure call) protocol, but this
detail is not important to client programs; they use the interface by
linking with a C++ library provided by the repository.  This library
layers a convenient set of classes and functions atop the raw SRPC
calls.<P>

The repository library's VDirSurrogate class provides access to
all kinds of Vesta source objects, including all forms of directory,
files, ghosts, and stubs.  It is a subclass of VestaSource that
implements its operations as SRPC calls to the repository server.
Many operations that are not available through the NFS interface are
provided in VDirSurrogate.  Operations on the LongId class and
most of the operations on the AccessControl class are also
available.<P>

The VestaSourceAtomic class provides a way to group several
VDirSurrogate operations into an atomic unit.  The repository user
interface tools (see <A HREF="repos-ui.1.html"><B>repos-ui</B>(1)</A>) are
built on top of VDirSurrogate and VestaSourceAtomic, and the Vesta
evaluator also makes use of VDirSurrogate.<P>

Access to lower-level repository functions is provided through the
SourceOrDerived
class.  These functions are used by the Vesta 
<A HREF="vesta.1.html">evaluator</A> and 
<A HREF="VestaWeed.1.html">weeder</A>.
The class gets its name from the fact that the repository stores both
the files that hold sources and those that hold deriveds in one
unified pool.  The class contains methods for creating and/or opening
files in the pool (used by the evaluator), for triggering the
repository's part of the weeding process (used by the weeder), and for
triggering a repository checkpoint to speed up crash recovery
(also used by the weeder).<P>

For low-level debugging and other sorts of wizardry, the
<A HREF="TestVDirSurrogate.8.html"><B>TestVDirSurrogate</B>(8)</A> program is
a test driver that can invoke most functions in VDirSurrogate and
LongId, while the <A HREF="TestShortId.8.html"><B>TestShortId</B>(8)</A>
program can invoke most functions in SourceOrDerived.
</BLOCKQUOTE>

<H3><A NAME="AccessControl">Access Control</A></H3>
<BLOCKQUOTE>
<P>

The repository supports replication and remote access between sites
under different administrations (called <I>realms</I>), with different
sets of authorized users and groups.  Therefore, the repository does
access control based on a global (worldwide) namespace of principals,
not simply the local Unix users and groups.  The access controls that
can be placed on sources in the repository are similar to ordinary
Unix access controls, but written in terms of global principal names
and slightly generalized.<P>

<B><A NAME="Principal identification and authentication">Principal identification and authentication</A></B><P>

Principals are identified by character string names of the form
<TT>user@realm</TT> or <TT>^group@realm</TT>.  A calling process attempting to
access the repository can claim and authenticate its identity as a
principal in several ways, described in this subsection.  An export
file read by the repository at startup controls which forms of
identification and authentication are accepted from which client
hosts.  The syntax of the export file is given in a later subsection.<P>

First, a principal can identify itself to the repository using numeric
Unix user and group identifiers.  This form of identification is
primarily for use by local NFS clients, and corresponds to the
AUTH_UNIX authentication flavor of the NFS protocol.  When the
repository receives a Unix uid or gid, it uses the local operating
system's user and group databases to translate the identifier to a
character-string user or group name, prepends <TT>^</TT> for groups, then
appends <TT>@</TT><I>realm</I> to obtain a global name.  Here <I>realm</I> is
the local realm name, specified as <I>[Repository]realm</I> in the Vesta
configuration file.<P>

Unix identities are authenticated only by origin: if the repository's
export table specifies that a particular client host is trusted for
Unix identities, then any request coming from that host with a Unix
identity is accepted as being from the identified principal.
(A host is identified by its IP address.)  This form of authentication
obviously offers poor security, but it is by far the most common form
used by NFS clients and thus must be supported.  The repository currently
does not check what port number an NFS request originates from.<P>

Second, a principal can identify itself by directly giving a global
user name, with the <TT>user@realm</TT> syntax.  This form of
identification is primarily for use by Vesta tools that communicate
with the repository through its SRPC interface, such as the
<A HREF="repos-ui.1.html"><B>repos-ui</B>(1)</A> tools,
<A HREF="vrepl.1.html"><B>vrepl</B>(1)</A>, and
<A HREF="vmaster.1.html"><B>vmaster</B>(1)</A>.  The current version of the
repository client-side libraries uses global identities automatically.
Older versions used Unix identities, so for compatibility the
repository will still accept them.<P>

Calling processes that identify themselves using global names do not
supply and authenticate their group memberships.  Instead, the
repository has a table of global group memberships for global users,
and it looks up a caller's user name in this table to determine which
groups the caller belongs to.  The repository's group table comes from
two sources.  First, group memberships for all locally-known users are
obtained from the local operating system's user and group databases.
Each uid and gid in these databases is translated into a global name
as described above, and the results are entered into the repository's
group membership table.  Second, the repository reads a file of
additional group memberships; the syntax of this file is given in a
later subsection.<P>

Currently global user names are also authenticated only by origin.
The export file can specify that a particular host is trusted to give
any global name, or that it is trusted only for global names with a
specified <TT>@realm</TT> suffix.<P>

Finally, in the future a principal may be able to identify and
authenticate itself using GSS-API.  The repository's export file can
specify which hosts GSS-API authentication will be accepted from, and
can optionally limit which realms the names can be from.  We
anticipate that GSS-API will most likely be used as an interface to
Kerberos.  Since Kerberos realm names are conventionally written in
upper case, the repository makes case-independent comparisons in its
access checking.  Thus a Kerberos principal named "fred@EXAMPLE.COM"
will match the Vesta global name "fred@example.com".<P>

When authenticating itself to other processes, the repository
determines which flavor to use from the
<I>[Repository]default_flavor</I> configuration setting.  NFS clients
always use the <TT>unix</TT> flavor.  Other clients use the
<I>[UserInterface]default_flavor</I> configuration setting by default;
this is normally <TT>global</TT>.<P>

<B><A NAME="Access controls">Access controls</A></B><P>

The access control on a file or directory in the repository has an
owner, a group, and mode bits, similar to ordinary Unix access
controls, but there are some differences.  <P>

The owner and group are both sets, not singletons.  They are
represented as the mutable attributes <TT>#owner</TT> and <TT>#group</TT>,
which are set-valued.  Any global user in the owner set has
ownership access to the object; any user that is a member of a global
group in the group set has group access.  The main reason we allow
multiple owners and groups is so that replicated data can have a local
owner and group in each realm that holds a copy, if desired.<P>

The primary mode bits are represented in the <TT>#mode</TT> attribute, as
the 3-digit octal number obtained by OR-ing the standard Unix mode
bits for read, write, and search access by owner, group, or world:
<PRE>
S_IRUSR   400   read permission: owner
S_IWUSR   200   write permission: owner
S_IXUSR   100   search permission: owner
S_IRGRP   040   read permission: group
S_IWGRP   020   write permission: group
S_IXGRP   010   search permission: group
S_IROTH   004   read permission: world
S_IWOTH   002   write permission: world
S_IXOTH   001   search permission: world
</PRE>

The setuid and setgid mode bits are represented by the <TT>#setuid</TT>
and <TT>#setgid</TT> attributes.  If the value of <TT>#owner</TT> that is in
the local realm (if any) is also a value of <TT>#setuid</TT>, the setuid
bit is set, otherwise not.  (If more than one value of <TT>#owner</TT> is
in the local realm, one of the values is chosen arbitrarily.  This is
the same value that will appear as the file's owner through the NFS
interface, as described below.)  The setgid bit works the same way,
using the values of <TT>#group</TT> and <TT>#setgid</TT>.<P>

A source that does not have an <TT>#owner</TT>, <TT>#group</TT>, or <TT>#mode</TT>
attribute inherits the corresponding value from its parent directory,
while a missing <TT>#setuid</TT> or <TT>#setgid</TT> attribute defaults to
empty.  This form of inheritance is needed in order to provide objects
that do not have their own attributes with an access control.  It is
also useful to save some space in the repository, since an object
whose parent has the same value for some access control does not need
to store its own copy of that attribute.<P>

The repository does not store execute permission bits for files.
Instead, each file has a single "executable" flag, which is immutable
for immutable files, mutable for mutable files.  If the executable
flag is true, the file's execute permission bits are the same as its
corresponding read bits; if not, they are all off.  The executable
flag and execute permission bits are implemented in the NFS glue layer
above the repository proper.  At the VestaSource interface, the 0111
bits of a <TT>#mode</TT> are always search permissions.  When the Unix chmod()
function is invoked on a file through the repository's NFS interface,
the file's executable flag is formed as the logical OR of the three
executable bits given.  When stat() is invoked, the executable
permission bits are formed as described above.<P>

A few complications arise when the repository is accessed using the
NFS protocol, since there is more information in a Vesta access
control than can be represented by NFS.  To obtain the numeric owner
uid reported in an object's NFS attributes, we search for a global
owner <TT>user@realm</TT>, where <TT>@realm</TT> is the local realm name.  If one is
found, the <TT>user</TT> portion is translated to a numeric id using the
local operating system's user database.  The group is then translated
in the same way.  If a locally known user and/or group is not found,
special values <TT>vforeign_uid</TT> and <TT>vforeign_gid</TT> specified in
the Vesta configuration file are used.  If more than one locally known
user or group is present, one of the alternatives is chosen
arbitrarily.  If the NFS setattr operation is used to change the owner
of an object (that is, if the Unix chown command is used), we first
search for all locally known owners and remove them, leaving any other
owners unchanged, then add the new owner.  Again groups are handled in
the same way.  Owners and groups that are removed in this way are also
removed from the <TT>#setuid</TT> and <TT>#setgid</TT> attributes if present.<P>

<B><A NAME="Access checking">Access checking</A></B><P>

Checking whether a calling process has access permission works as follows.<P>

First, the requested operation is classified by type: unrestricted,
agreement (could potentially violate the replica agreement
invariant), administrative (restricted to the system administrator),
ownership (for example changing the access control), read, write,
search, execute, del, setuid, or setgid.  The classification will
generally be unsurprising; odd cases are treated specifically below.<P>

If the client host is specified in the export file to have readonly access,
operations of types administrative, ownership, write, del, setuid, and
setgid are refused before considering any of the other rules below.<P>

Almost all operation types are permitted if the requesting process is
a Vesta administrator.  Three Vesta administrators with slightly
different privileges may be configured in vesta.cfg:
<I>[Repository]root_user</I>, <I>[Repository]vadmin_user</I>, and
<I>[Repository]vwizard_user</I>.  The vadmin user is provided as a
convenience, so that users can be authorized to administer Vesta
without being given the root password.  The root user has the same
privileges as vadmin, except that root is granted granted blanket
permission for setuid and setgid type operations.  The vwizard user
has the same privileges as vadmin, but is also allowed to perform
agreement operations, such as deleting children of master appendable
directories without leaving a ghost, creating children in nonmaster
appendable directories, etc.  Except for the initial creation of a
globally unique name under /vesta for packages that originate at your
site (see <A HREF="repository.8.html#Warning">warning</A> below), the vwizard feature should
be used only in emergencies, since it can create inconsistencies
between replicas.  Typically the administrative user names will be
<TT>root@realm</TT> (where realm is the local realm name),
<TT>vadmin@realm</TT>, and <TT>vwizard@realm</TT>.<P>

An unrestricted operation is always permitted, with no checking.<P>

An administrative operation is permitted only if the requestor is a Vesta
administrator.<P>

An ownership operation is permitted if the requestor's principal name
(or one of its aliases) matches one of the owner names in the access
control.<P>

Read, write, search, and execute operations are checked as follows: If
the corresponding world permission bit is set, access is granted.  If
the requestor's principal name (or an alias) matches one of the owner
names in the access control, and the corresponding owner permission
bit is set, then access is granted.  If one of the requestor's group
names matches one of the group names in the access control, and the
corresponding group permission bit is set, then access is granted.
Otherwise access is denied.  This algorithm is intentionally slightly
more liberal than that used in Unix, but matches it in the common cases.<P>

Operations on attributes are classified as follows: Reading attributes
is unrestricted.  Changing an attribute whose name does not begin with
<TT>#</TT> is a write operation.  With a few exceptions noted below, changing
an attribute whose name begins with <TT>#</TT> is an ownership operation.<P>

Changing <TT>#owner</TT> is normally an ownership operation; that is, as
in Unix System V, users are allowed to "give away" their files.  Some
Vesta tools (such as <B>vrepl</B> with the -a flag) need this ability.
However, if <I>[Repository]chown_semantics</I> is set to "BSD", changing
<TT>#owner</TT> through the NFS interface is an administrative operation.
Some Unix programs expect BSD semantics and may behave oddly with
System V semantics.<P>

Clearing or removing a value from the <TT>#setuid</TT> or <TT>#setgid</TT>
attribute is an ownership operation, but setting or adding a value to
<TT>#setuid</TT> is a setuid operation, to <TT>#setgid</TT> a setgid
operation.  A setuid operation is permitted if the requestor is root,
or if the requestor is the owner and the value being added is his own
name (including aliases).  A setgid operation is permitted if the
requestor is root, or if the requestor is the owner and the value
being added is a group that he is a member of.<P>

Deletion from an appendable directory, leaving a ghost, is a del
operation.  If <I>[Repository]restrict_delete</I> is set to 1, del
operations have the same permission checking as administrative
operations.  If it is set to 0, del operations have the same
permission checking as write operations on the directory.<P>

When an object is created, if the caller's user name (not including
aliases) is one of the owners of the new object's parent, then the new
object's <TT>#owner</TT> attribute is not automatically set, allowing the
object to inherit its parent's owner list.  Otherwise, the caller's
user name (but not any of its aliases) is automatically set into the
new object's <TT>#owner</TT> attribute as the sole owner.<P>

Each volatile root is owned by the "runtool" user with mode 755.
Because sources under a volatile root do not have attributes, these
permissions are inherited by all their descendents.  Thus, anyone can
examine the files and directories in the volatile tree, but only the
special runtool user can make changes.<P>

<B><A NAME="Export file">Export file</A></B><P>

As mentioned above, the repository's export file specifies which
client hosts may access the repository and what forms of
identification and authentication they may use.  The file format is as
follows.<P>

<UL>
<LI> Comments are introduced with "<TT>#</TT>", "<TT>;</TT>", or "<TT>//</TT>" and
continue to the end of the line.   Blank lines are allowed as well.<P>

<LI> Another file can be textually included with a line of the
form:
<BR>
<TT>.</TT> <I>filename</I>
<BR>
<P>

<LI> Other lines take the following form.  Here "[ ]" around an
element indicate that it is optional, and "..." indicates that the
preceding element may be repeated zero or more times.  Where
whitespace is shown, zero or more spaces or tabs may appear in the
file.
<BR>
<I>pattern</I> [<TT>:</TT>] [<I>level</I> [<I>flavor</I> [<I>arg</I>]]<TT>,</TT>]... [<I>level</I> [<I>flavor</I> [<I>arg</I>]]]
<BR>
</UL>
<P>

A <I>pattern</I> can be an Internet hostname, an Internet hostname
pattern with "<TT>?</TT>" or "<TT>*</TT>" characters as wildcards, an IP
address in dotted notation, or an IP subnet in the form
<I>address</I>/<I>netmask</I>, where <I>address</I> is in dotted notation,
and <I>netmask</I> either is in dotted notation, or is a single integer
indicating how many bits are set from the left (for example, /24 =
/255.255.255.0) .  The "<TT>?</TT>" wildcard matches any one character
except a dot ("<TT>.</TT>"), while the "<TT>*</TT>" wildcard matches zero or
more characters that are not dots.  Ordinary characters match
regardless of case.<P>

A <I>level</I> can be one of the following strings, case insensitive:
<TT>allow</TT>, <TT>readwrite</TT>, <TT>rw</TT>, <TT>readonly</TT>, <TT>ro</TT>, <TT>deny</TT>.  
The levels <TT>readwrite</TT> and <TT>rw</TT> are
synonyms for <TT>allow</TT>; <TT>ro</TT> is a synonym for <TT>readonly</TT>.<P>

A <I>flavor</I> can be one of the following strings, case insensitive:
<TT>unix</TT>, <TT>global</TT>, <TT>gssapi</TT>, <TT>all</TT>, <TT>any</TT>.  Any is a
synonym for all.<P>

If no (level, flavor, arg) tuples appear for a given pattern, "allow
all" is supplied by default.  If the flavor is omitted from a tuple,
it defaults to <TT>all</TT>.<P>

The optional <I>arg</I> is an argument to the flavor.  Only "allow
global", "readonly global", "allow gssapi", and "readonly gssapi"
take an argument.  This argument is a pattern for the realm
that the global name must originate from, with "<TT>?</TT>" and "<TT>*</TT>"
wildcards matched as in hostname patterns.  If this argument is
omitted, any global name is accepted.<P>

When checking whether a request should be admitted, the repository
scans the export file looking for the last (pattern: level, flavor,
arg) tuple whose pattern, flavor, and arg match.  If one is found, its
level applies to this request.  If not, the request is denied.<P>

Here is an example:
<PRE>
; Sample export file
16.0.0.0/8: readonly global *.example.com 
*.x.example.com: allow unix, allow global x.example.com
badguy.x.example.com: deny
*.z.example.com: allow global y.example.com
</PRE>

The first line says that any host on network 16.0.0.0 may have
read-only access to the repository if it supplies a global identity of
the form <TT>user@*.example.com</TT>.  The second line says that hosts whose
names match the pattern <TT>*.x.example.com</TT> may have read/write access
to the repository if they supply either a Unix identity, or a global identity
of the form <TT>user@x.example.com</TT>.  If a request matches both lines,
the second one will take precedence.  
The third line makes the host badguy.x.example.com an exception; it is not 
granted any access.  The fourth line allows hosts from the 
domain <TT>*.z.example.com</TT> to use names in the global realm <TT>y.example.com</TT>.<P>

<B><A NAME="Group file">Group file</A></B><P>

As mentioned above, the repository's group file gives a (partial) list
of which global groups various global principals belong to.
The file format is as follows.<P>

<UL>
<LI> Comments are introduced with "<TT>#</TT>", "<TT>;</TT>", or "<TT>//</TT>" and
continue to the end of the line.  Blank lines are allowed as well.<P>

<LI> Another file can be textually included with a line of the
form:
<BR>
<TT>.</TT> <I>filename</I>
<BR>
<P>

<LI> Other lines take the following form.  Here "[ ]" around an
element indicate that it is optional, and "..." indicates that the
preceding element may be repeated zero or more times.  Where
whitespace is shown, zero or more spaces or tabs may appear in the
file.  
<BR>
<I>name</I> <TT>:</TT> [<I>group</I> [<TT>,</TT>]]... [<I>group</I>] 
<BR>
</UL>
<P>

Here <I>name</I> is a global user name (<TT>user@realm</TT>) and each
<I>group</I> is a global group name (<TT>^group@realm</TT>).  The line says
that <I>name</I> is a member of each group listed.  If the same name
appears on several lines, the memberships accumulate.<P>

Here is an example:
<PRE>
// Vesta repository group file for x.example.com
tom@x.example.com: ^users@y.example.com ^admins@y.example.com
dick@x.example.com: ^users@y.example.com
harry@y.example.com: ^users@y.example.com ^admins@y.example.com
</PRE>

The first line says that besides the locally-known groups he is a
member of, <TT>tom@x.example.com</TT> is also a member of some
<TT>y.example.com</TT> groups.  This could be useful if some sources from
<TT>y.example.com</TT> are replicated in the <TT>x.example.com</TT> repository and
<TT>tom</TT> needs access to them.  The situation is similar for
<TT>dick</TT>.  On the third line, <TT>harry@y.example.com</TT> is indicated to
be a member of some <TT>y.example.com</TT> groups.  This line could be
useful if <TT>harry</TT> accesses the <TT>x.example.com</TT> repository remotely
when logged in at <TT>y.example.com</TT>.  Without it, <TT>harry</TT> would not
obtain his group memberships when accessing the <TT>x.example.com</TT>
repository, since this repository does not preload its group table
with the local user and group database from <TT>y.example.com</TT>.<P>

<B><A NAME="Aliases and the alias file">Aliases and the alias file</A></B><P>

As an added convenience feature, the repository can be told to
recognize a global user or group name as having one or more <I>aliases</I>.
When a client authenticates itself as possessing a name that has some
aliases, it is given the privileges of the aliases as well as those of
the authenticated name.  Aliases are applied after the client's
principal identification is translated to a global name, so they work
even with Unix identification.  The <I>[Repository]root_user</I> is not
allowed as an alias.<P>

For example, if user <TT>mann</TT> has accounts in realms <TT>x.example.com</TT>
and <TT>y.example.com</TT>, and he sometimes logs in at <TT>x.example.com</TT> and
remotely accesses the repository at <TT>y.example.com</TT>, it would be
useful for the <TT>y.example.com</TT> repository to regard
<TT>mann@x.example.com</TT> as having the alias <TT>mann@y.example.com</TT>.  <P>

The aliasing mechanism is neither symmetric nor transitive by default:
<UL>
<LI> If <TT>mann@x.example.com</TT> has the alias
<TT>mann@y.example.com</TT>, that does not automatically give
<TT>mann@y.example.com</TT> the alias <TT>mann@x.example.com</TT>.  If a
symmetric alias is desired, both directions of aliasing must be listed
explicitly in the alias file.<P>

<LI> If <TT>mann@x.example.com</TT> has the
alias <TT>mann@y.example.com</TT> and <TT>mann@y.example.com</TT> has the
alias <TT>mann@z.example.com</TT>, that does not automatically give
<TT>mann@x.example.com</TT> the privileges of <TT>mann@z.example.com</TT>.
If the latter is desired, <TT>mann@x.example.com</TT> must be 
given the alias <TT>mann@z.example.com</TT> explicitly.
</UL>
<P>

A user alias can be employed as another way to get group-like functionality.
For instance, if user <TT>manager@x.example.com</TT> should be automatically
allowed access to files owned by <TT>tom</TT>, <TT>dick</TT>, and
<TT>harry@x.example.com</TT>, they can be listed as aliases.<P>

Groups can be aliased as well.  For example, if realms
<TT>x.example.com</TT> and <TT>y.example.com</TT> are working together on the
Wonka project and both have a local group named <TT>wonka</TT>, it can be
useful to alias <TT>^wonka@x.example.com</TT> to <TT>^wonka@y.example.com</TT>
(and vice versa) at both sites.  That way, users at either site can
obtain group access to a directory replicated from the other site,
even if only one of the two groups is on the directory's group access
control list.<P>

The alias file has the same syntax as the group file, except that user
names may appear in place of group names.  It is meaningless for a
user name to be aliased to a group name, or vice versa.  When a
reciprocal alias is needed, both directions must be included
explicitly.  For the examples above, the aliases file would read:
<PRE>
# Sample aliases file
mann@x.example.com: mann@y.example.com
mann@y.example.com: mann@x.example.com
manager@x.example.com: tom@x.example.com, dick@x.example.com, harry@x.example.com
^wonka@x.example.com: ^wonka@y.example.com
^wonka@y.example.com: ^wonka@x.example.com
</PRE>

<B><A NAME="Limitations">Limitations</A></B><P>

Changes to the local passwd and group databases are not all tracked
automatically by the repository.  This can result in users not getting
quite the right privileges after a change until the next time the
repository's access control tables are reloaded.  The addition of a
new user or new group is handled automatically, but other cases are
not, such as when a user is added to a group, is removed from a group,
is given a different uid, or is deleted from the system.  (The
repository has no way of knowing when such a change has happened, and
for reasons of efficiency it maintains its own in-memory cache of the
local passwd and group databases.)<P>

In more detail, whenever the repository encounters a uid or gid that
is unknown to it (i.e. that has been added since the repository last
acquired user/group information from the OS), it attempts a complete
reload of all access control data both from the host OS and from the
export, alias, and group files.  This can fail if there is a parsing
error in the export, alias, or group file, in which case an error
message is logged by the repository.  If that happens, the repository
simply adds an entry for the new uid/gid after getting information
from the OS.<P>

The <A HREF="vaccessrefresh.8.html"><B>vaccessrefresh</B></A> utility can be
used to explicitly ask the repository to pick up changes in the OS
user/group databases and its own group, alias, and export files.  When
using <B>vaccessrefresh</B>, any errors in parsing the export, alias,
and group files will be reported to the user.  Restarting the
repository will also cause it to pick up all access control changes,
but this is no more effective than using <B>vaccessrefresh</B>.<P>

Using the Unix newgrp command with a password to dynamically enter a
new group that you are not a static member of is not supported by the
repository.  Currently you may get the group's privileges when going
through the NFS interface, but you will never get them through the
SRPC interface.  In the future this feature is more likely to be
disabled entirely than made to work in all cases.<P>

If several different user names map to the same Unix uid, the
repository will not treat them all as aliases for one another.
A user logged in as this uid will get the privileges only of the first
name that maps to it.<P>

Although <TT>gssapi</TT> is recognized as a flavor in the export file,
GSS-API authentication is not yet implemented, so allowing it has no
effect.
</BLOCKQUOTE>

<H3><A NAME="Performance Tuning">Performance Tuning</A></H3>
<BLOCKQUOTE>
<P>

Optimizing the performance of any server application is a complicated
process and usually requires trial and error.  This section provides
some background on different factors affecting the repository's
performance and the <A HREF="repository.8.html#Configuration">configuration settings</A>
available for controlling those factors.<P>

<B><A NAME="File Descriptor Caching">File Descriptor Caching</A></B><P>

In order to process a read or write to a source or derived file, the
repository must have an open file descriptor for it.  Since it is
common for the multiple reads/writes of the same file to occur close
together in time, the repository keeps opened file descriptors in its
<I>file descriptor cache</I>.  This avoids the time cost of opening and
closing a file descriptor on each read/write operation.<P>

Like all processes, the repository server has a limit on the total
number of file descriptors it can have open at any point in time.
This limit can be set before starting the server, or the
<I>[Repository]descriptor_limit</I> configuration setting can be used to
have the repository set the limit when it starts.  (Note that on some
platforms this setting can cause the repository to make special calls
to enable larger numbers of file descriptors.)<P>

The repository keeps at most half of its limit of open files in the
file descriptor cache.  If it already has that many file descriptors
open and it needs to open another, it will close the least recently
used file descriptor.  This is called <I>evicting</I> a cached file
descriptor.  The repository will also close file descriptors that have
not been used in the last 10 minutes.  This is called <I>expiring</I> a
cached file descriptor.<P>

With the <A HREF="vreposmonitor.8.html"><B>vreposmonitor</B></A> utility, you
can see the number of file descriptors evicted and expired over time.
If your repository has a high rate of evictions and a low rate of
expirations, you should probably increase its file descriptor limit.
You should particularly watch out for short periods of time when the
number of evictions is significantly larger than the number of file
descriptors in the cache, as that is a clear indication that the
repository needs more file descriptors than it has available.<P>

<B><A NAME="File Descriptor Cache Locking">File Descriptor Cache Locking</A></B><P>

The repository stores all source and derived files in a combined pool.
Individual files in this pool are identified by a 32-bit integer
called a <I>shortid</I>.<P>

The file descriptor cache is essentially a large hash table indexed by
shortid.  Any time a file descriptor is needed, exclusive access to
the file descriptor cache must be obtained.  This can cause contention
between different threads and slow down the server.<P>

To alleviate this, the file descriptor cache can be broken up into
multiple independent tables, each with its own lock.  The file
descriptor cache table for a given shortid is found using the
low-order bits of the shortid.  You can control how many of the
low-order bits are used, and thus how many independent tables there
are, with the <I>[Repository]fdCache_split_bits</I> configuration
setting.  (Note that each additional bit you use multiplies the number
of independent file descriptor cache tables by 2.)<P>

You should avoid the temptation to use a large number of tables, as
the number of file descriptors cached in each table is fixed.  The
total limit on cached file descriptors is divided evenly among the
independent file descriptor cache tables at startup.  Here's one
possible way this division could happen:<P>

<UL>
<LI> The repository has a total file descriptor limit of 2048.<P>

<LI> The repository reserves half these file descriptors (1024) for
the file descriptor cache.<P>

<LI> <I>[Repository]fdCache_split_bits</I> is set to 4, creating 16
independent file descriptor cache tables.<P>

<LI> This means that each file descriptor cache table will hold a
total of 64 file descriptors.
</UL>
<P>

When a new file descriptor is needed in one of these independent
caches and its limit has already been reached, the least-recently used
one in that table will be evicted.  If the number of descriptors in
each independent file descriptor cache is small, this could create a
"hot spot" where one table has a higher rate of evictions than others.<P>

<B><A NAME="NFS Threads">NFS Threads</A></B><P>

At startup, the repository creates a fixed number of threads to
process NFS requests.  The number of threads is controlled by the
<I>[Repository]threads</I> configuration setting.<P>

More NFS threads can improve repository performance for user
filesystem operations and tool invocations by allowing greater
parallelism, but only up to a certain point.  The exact number that
will work best in a given situation will be dependent on many factors,
and experimentation is the best way to find a good value.<P>

In recent experience (circa 2003-2005) with 4-CPU servers with
hundreds of client hosts, we have found that 32 threads works well,
while doubling the number to 64 threads performs less well.  For
smaller installations, a lower number of threads will probably work
fine.<P>

<B><A NAME="NFS Buffering">NFS Buffering</A></B><P>

The NFS protocol uses UDP which lacks guaranteed delivery.  The
operating system on the server side receives request packets and
buffers them until the server process consumes them.  If more requests
arrive than will fit in the available buffer space, they are
discarded.<P>

This does not cause incorrect behavior, but it can cause a delay in
processing during periods of high traffic.  When an NFS client doesn't
receive a response to a request within a certain period of time, it
retransmits its request.<P>

The <I>[Repository]bufreqs</I> setting controls how much UDP buffer
space the repository server asks the operating system to use to hold
incoming requests.  The setting is an integer, and the server asks the
operating system for enough space to hold approximately that number of
the largest expected requests (i.e. write operations that include a
block of bytes to be written).  Increasing this setting can reduce the
loss of requests due to insufficient buffer space.<P>

Unfortunately, there is no way to measure whether requests are being
lost due to insufficient buffer space, so it's difficult to know when
this setting will improve performance.  Also, the operating system
will usually only grant UDP buffer requests up to a certain size, and
experimentation is usually required to determine how much buffer the
OS will give to the repository.<P>

<B><A NAME="NFS Duplicate Suppression">NFS Duplicate Suppression</A></B><P>

As mentioned <A HREF="repository.8.html#NFS Buffering">above</A>, NFS clients retransmit
requests if they don't receive a response within a certain period of
time.  Aside from insufficient buffer space at the server, there are
several other causes:<P>

<UL>
<LI> The request not reaching the server<P>

<LI> The response not reaching the client<P>

<LI> The server being too busy to complete the request before the
client re-transmits it
</UL>
<P>

In some cases it is harmless for the server to repeat a previously
performed request (such as reading a file), although it wastes time
and I/O resources.  In other cases (such as creating or deleting a
file or directory), repeating a previously completed request will give
a different result.  For this reason, the repository server remembers
requests that it is currently processing and that it has recently
completed to suppress duplicate transactions.<P>

When a duplicate of a request currently being processed arrives, the
server drops it as a response will be sent when the server finishes
processing it.  When a duplicate of a completed request arrives, the
server retransmits the result it previously sent to the client.  You
can observe the rate of duplicate requests with the
<A HREF="vreposmonitor.8.html"><B>vreposmonitor</B></A> utility.<P>

Because it takes memory to store records of duplicate NFS requests,
the repository only stores a certain number of them.  The number that
it retains can be controlled with the <I>[Repository]dupe_table_max</I>
configuration setting.  When the limit is reached, the oldest one is
discarded.<P>

If a request comes in that is a duplicate of a request that has been
discarded from its duplicate suppression table, the repository server
will not know and will re-perform the operation.  This can cause
strange errors such as "file/directory already exists" errors when
trying to create files/directories.  If you encounter such errors, you
should try increasing <I>[Repository]dupe_table_max</I>.<P>

<B><A NAME="NFS Duplicate Suppression Locking">NFS Duplicate Suppression Locking</A></B><P>

When checking for a duplicate, or adding entries to the duplicate
suppression tables when starting or completing the processing of a new
call, exclusive access to the table must be acquired.  This locking is
another possible point of contention between different threads in the
repository.<P>

Similar to the file descriptor cache, it is possible to break up the
duplicate suppression table into multiple independent tables each with
its own lock.  There are two configuration settings which control the
number of tables and the hashing of NFS requests into the different
tables:<P>

<UL>
<LI> <I>[Repository]dupe_hash_xid_bits</I> controls the number of bits of
the NFS RPC transaction ID (or XID) used in the hash.  (XIDs are
identifying numbers assigned by the NFS client.)<P>

<LI> <I>[Repository]dupe_hash_ip_bits</I> controls the number of bits in the
client host IP address used in the hash.  This setting is most useful
for repositories with multiple client hosts.  Single-host
installations should use the default of zero.
</UL>
<P>

The total number of duplicate suppression tables is 2 to the power of
the sum of these two settings, so increasing either setting by 1
doubles the number of independent duplicate suppression tables.  Note
that each independent table holds <I>[Repository]dupe_table_max</I>
entries.  If memory is a concern, you may wish to decrease that
setting when increasing the number of duplicate suppression tables.<P>

<B><A NAME="Copy-on-Write Limits">Copy-on-Write Limits</A></B><P>

In certain cases, a write performed through the repository's NFS
interface will cause a copy to be made first.  This happens because
files which appear writable may refer to an underlying file which is
actually immutable.  For example, when you check out a package, the
files in the working directory initially use the same storage as the
immutable files in the old version.  Before a write to such a file can
be processed, it must be copied.<P>

The repository limits the number of threads concurrently performing
copy-on-write operations to the number specified in the
<I>[Repository]cow_max</I> setting, which defaults to 4.  If this many are
already in progress, new threads that need to perform a copy-on-write
will wait.<P>

<B><A NAME="SRPC Threads">SRPC Threads</A></B><P>

Most non-NFS operations to the repository (e.g. checkout, checkin,
replication) go through the VestaSource SRPC interface.  The
<I>[Repository]VestaSourceSRPC_max_running</I> configuration setting
controls the number of threads allowed to be concurrently processing
requests.  The number of threads specified by the setting is created
on server startup.<P>

There is also s separate SRPC interface used by the evaluator and
weeder which has a separate configuration setting:
<I>[Repository]ShortIdSRPC_max_running</I>.<P>

Both of these SRPC interfaces default to 32 running.  Increasing the
number of concurrent requests allowed may increase performance when
there are a large number of client machines.  However, many operations
contend with each other for internal locks and other resources so
allowing more concurrent requests will not necessarily result in
higher overall throughput.<P>

<B><A NAME="SRPC Timeouts">SRPC Timeouts</A></B><P>

There are three ways that the repository server may need wait to
receive data from a client:<P>

<UL>
<LI> A VestaSource SRPC client (e.g. repository tools like
<A HREF="vcheckout.1.html"><B>vcheckout</B></A>) may start a call and the
repository server will wait for it to send the call argument data.<P>

<LI> Similarly, a ShortId SRPC client may start a call and the
repository server will wait for it to send the call argument data.<P>

<LI> When a tool is running, the repository server acts like a client
to the evaluator, making calls back to it to request information about
the contents of the temporary root filesystem used to run the tool.
(This is how the evaluator is notified of filesystem accesses during
tool runs, which it then records as dependencies.)
</UL>
<P>

To avoid tying up server resources for an indefinite period of time
when a client is unresponsive, the repository will close connections
after waiting to receive data for a certain amount of time.  There are
three configuration settings which control this:<P>

<UL>
<LI> <I>[Repository]VestaSourceSRPC_read_timeout</I> specifies the maximum
number of seconds to wait for data from a VestaSource SRPC client.<P>

<LI> <I>[Repository]ShortIdSRPC_read_timeout</I> specifies the maximum
number of seconds to wait for data from a ShortId SRPC client.<P>

<LI> <I>[Repository]EvaluatorDirSRPC_read_timeout</I> specifies the maximum
number of seconds to wait for a response from the evaluator for
information about the contents of a temporary filesystem used to run a
tool.
</UL>
<P>

The default for all of these settings is a generous five minutes (300
seconds).  If you suspect slow or unresponsive clients are tying up
server resources, you may wish to decrease these values to a minute or
less.  (Note that long-running clients from which the server is not
waiting for data may have open connections that are idle longer than
these setting.)
</BLOCKQUOTE>

<H3><A NAME="Flags">Flags</A></H3>
<BLOCKQUOTE>
<P>

<DL>
<DT><A NAME="-h">-h</A><DD>
Print a brief usage message and exit.
<DT><A NAME="-d">-d <I>level</I></A><DD>
Turn on additional debugging output (to standard error) 
or other debugging modes.
The default is <I>[Repository]debug_level</I>.
The <I>level</I> is the bitwise <I>or</I> of the following:
<UL>
<LI> 0x00001 - SRPC - log a message when a client dies (or the like).
<LI> 0x00002 - NFS interface - log arguments and results.
<LI> 0x00004 - FdCache - log debugging messages.
<LI> 0x00008 - SourceOrDerived::doDeletions - log disposition of each ShortId.
<LI> 0x00010 - SourceOrDerived::doDeletions - log debugging messages.
<LI> 0x00020 - SourceOrDerived::doDeletions - suppress actual deletion 
(unlink). 
<LI> 0x00040 - VDirEvaluator - log debugging messages.
<LI> 0x00080 - Recovery - do not try to finish an incomplete weed.
<LI> 0x00100 - VMemPool - log debugging messages.
<LI> 0x00200 - Startup - if a file named "core" exists in the current directory, rename it to core.DATE.TIME, where DATE.TIME are the current date and time.
<LI> 0x00400 - NFS interface - log references to stale handles.
<LI> 0x00800 - Mastership transfer - log debugging messages.
<LI> 0x01000 - File copy-on-write - log occurrences.
<LI> 0x02000 - Access control - log parsing of tables.
<LI> 0x04000 - Replication - log debugging messages.
<LI> 0x08000 - Gardener (background thread that prunes away volatile directories from dead evaluators) - log debugging messages.
<LI> 0x10000 - Shortid block leases - log debug messages when they are acquired, renewed, and released, plus a summary of current leases after recovery and when checkpointing
</UL>
<DT><A NAME="-f">-f</A> <I>first-ckp</I><DD>
Specifies which checkpoint recovery should begin with.  By default,
the newest committed checkpoint is used, if any.  Checkpoints are numbered 
1, 2, 3, etc.  A checkpoint number of 0 means to recover entirely from
logs, starting at the beginning of time.  Recovery always continues to
the end of the last log file.
<DT><A NAME="-D">-D</A> <I>dump-file-name</I><DD>
Debug capability primarily of interest to developers: after recovery,
write out a text dump of the contents of the repository's in-memory
representation of all directories and attributes to a file.  Once the
dump is complete, the repository exits immediately.  This can be
useful for comparing the repository's state at two points in time
(e.g. just before and just after a checkpoint).
</DL>
<P>

</BLOCKQUOTE>

<H3><A NAME="Weeding Hooks">Weeding Hooks</A></H3>
<BLOCKQUOTE>
<P>

The repository manages a large pool of storage used for both source
files and derived files.  During weeding, the repository is
responsible for deleting files from that collection.  In some cases,
external software may want to know the precise details of the files
that have been kept and deleted or even ask for extra files to be
kept.  This could be necessary for file caching and distribution
systems or implementing administrative policies.<P>

The repository daemon provides a small number of <I>hooks</I> into its
weeding process.  These are controlled by optional configuration file
settings.<P>

<UL>

<LI> Before preparing the complete list of files to keep, the
repository will run the command configured in
<TT>[Repository]also_keep_weed_hook</TT>.  This command can update a file
with a list of additional files to be kept, even if they would not
otherwise be kept.
<LI> Before starting deletions the repository will run the command
configured in <TT>[Repository]pre_delete_weed_hook</TT>.
<LI> After deletions are complete the repository will run the command
configured in <TT>[Repository]post_delete_weed_hook</TT>.
</UL>
<P>

The weeding hook commands are executed with "<TT>/bin/sh -c
<I>command</I></TT>", so simple in-line shell scripts can be used.  The
weeding hook commands are executed as the same user running the
repository daemon.  The weeding hook commands will have the same
standard input, output, and error as the repository daemon.  The
repository daemon waits for each weeding hook command to complete, so
they should be designed to complete quickly to avoid delaying the
weeding process.<P>

Information is communicated to the hook commands through the following
environment variables:<P>

<DL>
<DT>VWEED_KEEP_TIME<DD>
Any files changed after this time will be kept during the deletion
phase.  This time is chosen by the weeder client program
(e.g. <A HREF="VestaWeed.1.html">VestaWeed</A> or
<A HREF="QuickWeed.1.html">QuickWeed</A>) when it starts.  The time is a
UNIX timestamp as an integer number of seconds since the epoch.
<DT>VWEED_ALSO_KEEP_SHORTID<DD>
The shortid in hex of the file which the <TT>also_keep_weed_hook</TT>
should update with additional files to keep.  The file must contain
shortids to be kept as an ASCII printed hex number 0-padded to exactly
8 hex digits each followed by a newline.  Note that <B>any errors in
formatting in this file will cause the weeding process to fail without
performing deletions</B>.  This environment variable will be available
for other hook commands (<TT>pre_delete_weed_hook</TT>,
<TT>post_delete_weed_hook</TT>) but the file will be read-only.  If no
<TT>also_keep_weed_hook</TT> is configured, this variable is set to "0".
<DT>VWEED_ALSO_KEEP_FILE<DD>
The full filesystem path to the additional keep list file.  This is
provided as a convenience so hooks need not convert the shortid to a
path.  If no <TT>also_keep_weed_hook</TT> is configured, this variable is
set to the empty string.
<DT>VWEED_KEEP_SHORTID<DD>
The shortid in hex of the file which contains a list of shortids of
the files to be kept during weeding.  Any file which is either on this
list or was changed after the keep time will be kept.  All other files
will be deleted.  The list is not available for
<TT>also_keep_weed_hook</TT>, so this variable is set to "0" for it.
This list is the full combined list including derived files
identified by the weeder client program, source files currently in the
repository, and any extra files supplied by the
<TT>also_keep_weed_hook</TT>.  This list is in a sorted order, with each
shortid to be kept as an ASCII printed hex number followed by a
newline.  The file should not be modified by the hook command, and
will have read-only permissions to discourage any modifications.
<DT>VWEED_KEEP_FILE<DD>
The full filesystem path to the keep list file.  This is provided as a
convenience so hooks need not convert the shortid to a path.
<DT>VWEED_DELETED_SHORTID<DD>
The shortid in hex of the file which contains a list of shortids of
the files which were deleted.  This list is built as the deletions are
processed.  Obviously this information is unavailable before deletions
have been performed, so this variable is set to "0" for the pre-delete
hook.  This list is in a sorted order, with each shortid that was
deleted as an ASCII printed hex number followed by a newline.  The
file should not be modified by the hook command, and will have
read-only permissions to discourage any modifications.
<DT>VWEED_DELETED_FILE<DD>
The full filesystem path to the delete list file.  This is provided as
a convenience so hooks need not convert the shortid to a path.  For
the pre-delete hook this variable is set to the empty string.
</DL>
<P>

</BLOCKQUOTE>

<H3><A NAME="Configuration">Configuration</A></H3>
<BLOCKQUOTE>
<P>

The following values are obtained from the <I>[Repository]</I> section of the
Vesta configuration file (vesta.cfg).<P>

<DL>
<DT><I>alias_file</I><DD>
The file used to specify equivalent alternative names for global
users.  See the <A HREF="repository.8.html#AccessControl">Access Control</A> section
above. If set to a relative path, this will be interpreted relative to
<I>metadata_root</I>.  Typically set to <TT>repos/alias</TT> or
<TT>/etc/vesta/repos.alias</TT>.
<DT><I>allow_symlink</I><DD>
If this parameter is set to 1, symbolic links can be created through the
NFS interface using the symlink() system call; if 0, they cannot.  Note that 
symlinks can be created only in appendable directories even with this
flag turned on, and that the "latest" symlink is created through the
VestaSource SRPC interface and is unaffected by this flag.
<DT><I>also_keep_weed_hook</I><DD>
An optional command to run to supply additional files to keep during
weeding.  See the "<A HREF="repository.8.html#Weeding Hooks">Weeding Hooks</A>" section above.
<DT><I>backup_ckp</I><DD>
If set to 1, and log_dir2 is also set, a backup copy of each checkpoint
is also stored in metadata_root/log_dir2.
<DT><I>bufreqs</I><DD>
Sets the size of the buffer associated with the UDP socket on which
NFS requests are received.  The units are (a generous estimate of) the
maximum size of an NFS request.
<DT><I>chown_semantics</I><DD>
If this parameter is set to <TT>BSD</TT>, only an administrator can change
a source's <TT>#owner</TT> attribute through the NFS interface.
If it is set to <TT>System-V</TT>, the current
owner can also change it.  The current owner can always change this
attribute through the SRPC interface.
<DT><I>cow_max</I><DD>
Maximum number of file copy-on-write operations in progress at once.
If not set, the default is 4.
<DT><I>debug_level</I><DD>
Sets the default value for the <A HREF="repository.8.html#-d">-d flag</A> (see above).
<DT><I>default_flavor</I><DD>
The identity flavor that the repository uses when authenticating
itself to other processes.  Normally set to <I>global</I> at present.
<DT><I>descriptor_limit</I><DD>
An integer.  When the repository starts up, it will attempt to
increase the limit on the number of file descriptors it can have open
at once to this number.  On some platforms, this will take additional
action to enable support for large numbers of file descriptors.  If
not set, the repository will not attempt to change its open file
descriptor limit.
<DT><I>dupe_hash_ip_bits</I><DD>
An integer between 0 and 8.  Controls the distribution of incoming NFS
RPC calls among independent duplicate suppression tables based on IP
address.  Specifically, sets the number of low-order bits of the
source IP address used as part of a hash table key.  The total number
of duplicate suppression tables will be
2^(<I>dupe_hash_ip_bits</I>+<I>dupe_hash_xid_bits</I>).  As of this
writing, one of the largest current Vesta installations uses 3.  You
should use a value less than log2(<I>number of client hosts</I>) for
this setting.  If not set, defaults to 0 (on the assumption that most
installations will have a very small number of client hosts).
<DT><I>dupe_hash_xid_bits</I><DD>
An integer between 0 and 8.  Controls the distribution of incoming NFS
RPC calls among independent duplicate suppression tables based on RPC
transaction ID.  Specifically, sets the number of bits of the RPC
transaction ID used as part of a hash table key.  The total number of
duplicate suppression tables will be
2^(<I>dupe_hash_ip_bits</I>+<I>dupe_hash_xid_bits</I>).  As of this
writing, one of the largest current Vesta installations uses 4.  If
not set, defaults to 2.
<DT><I>dupe_table_max</I><DD>
Number of NFS RPC replies to buffer for duplicate suppression.  If a
client retransmits a request that the server has recently replied to,
it will be replied to from the buffer instead of being redone.  Note
that each of the independent suplicate suppression tables will retain
this many recently completed NFS RPC replies.  If you increase
<I>dupe_hash_ip_bits</I> or <I>dupe_hash_xid_bits</I> by more than 1, you
may want to also decrease this setting.
<DT><I>EvaluatorDirSRPC_read_timeout</I><DD>
Maximum number of seconds the server will wait for data from an
evaluator when calling it for information about the contents of a
volatile directory to service a request.  This prevents the server
from waiting indefinitely for a suspended or misbehaving evaluator.
If it's not set, it defaults to 300 (5 minutes).  (Note that the time
between individual calls on a connection can be longer than this.)
<DT><I>export_file</I><DD>
The file used to specify which remote hosts are allowed to access the
repository and what authentication they must use.  See the
<A HREF="repository.8.html#AccessControl">Access Control</A> section above.  If set to a
relative path, this will be interpreted relative to
<I>metadata_root</I>.  Typically set to <TT>repos/export</TT> or
<TT>/etc/vesta/repos.export</TT>.
<DT><I>fdCache_split_bits</I><DD>
An integer between 0 and 31 (recommended values: 2-8).  Controls the
number of independent file descriptor cache tables the repository
uses.  Specifically, sets the number of low-order bits of a shortid
used to select the file descriptor cache table.  There will be
2^<I>fdCache_split_bits</I> tables.  More tables means reduces lock
contention, but has diminishing benefit with higher values.  As of this
writing, one of the largest current Vesta installations uses 6
(i.e. 64 tables).  If not set, defaults to 2 (4 tables).
<DT><I>group_file</I><DD>
The file used to specify (additional) members for global groups.  See
the <A HREF="repository.8.html#AccessControl">Access Control</A> section above.  If set to a
relative path, this will be interpreted relative to
<I>metadata_root</I>.  Typically set to <TT>repos/group</TT> or
<TT>/etc/vesta/repos.group</TT>.
<DT><I>honor_client_gids</I><DD>
For authentication, NFS clients send a numeric user ID and a list of
numeric group IDs.  Each of these maps to some global name (as
described above under <A HREF="repository.8.html#Principal identification and
authentication">"Principal identification and authentication"</A>).
Normally the user ID is sufficient as the repository server already
knows the group memberships of each user.  For this reason, the
repository by default ignores the group IDs sent by NFS clients.
However, if a user uses <TT>newgrp(1)</TT> to become a member of a new
group, the groups IDs sent by the client would be more current than
the information the repository has.  (<TT>newgrp(1)</TT> probably isn't
very useful with the repository anyway, as it can't affect the SRPC
interface used by tools like
<A HREF="vcheckout.1.html"><B>vcheckout</B></A>).)  Also, if the user's groups
have changed since the last time the repository loaded the user and
group information from the OS, the NFS client may have a more
up-to-date list of group memberships.  (A re-load of user and group
information can be explicitly requested with the
<A HREF="vaccessrefresh.8.html"><B>vaccessrefresh</B></A> utility.)  If it is
equal (without regard to case) to "yes", "on", or "true", or can be
parsed as an integer that is non-zero, the repository will honor the
list of group IDs sent by NFS clients.  If it is equal (without regard
to case) to "no", "off", or "false", or can be parsed as an integer
that is zero, the repository will ignore the list of group IDs sent by
NFS clients.  If not set, defaults to "false".
<DT><I>Landlord_sleep_max</I><DD>
Some clients use the ShortId SRPC interface to acquire leases on
blocks of shortids for allocation purposes.  A background thread
called the Landlord thread is responsible for releasing expired
leases.  This setting determines the default length of time it sleeps
between expirations.  If not set, defaults to 3600 seconds (1 hour).
It can be set lower but not higher.  Normally there's no reason to
change this setting.
<DT><I>Landlord_sleep_min</I><DD>
Related to the previous setting.  If the Landlord thread find itself
with too much work to do, it will dynamically decrease the amount of
time it sleeps between expirations.  This setting controls the minimum
length of time it sleeps.  If not set, defaults to 60 seconds.  It
cannot be set higher than 1/2 of <I>Landlord_sleep_max</I>.  Normally
there's no reason to change this setting.
<DT><I>Landlord_worklist_size</I><DD>
Related to the previous two settings.  This setting controls the
maximum number of shortid block leases the Landlord thread will expire
each time it wakes up.  If there are more leases to expire than this,
it will try to sleep for a shorter period next time.  If there are
less leases to expire than this, it will try to sleep for a longer
period next time.  If not set, defaults to 128 leases.  Normally
there's no reason to change this setting.
<DT><I>log_dir</I><DD>
The recovery log and checkpoints go in metadata_root/log_dir.  The
log_dir must end with "/" (or be empty).
<DT><I>log_dir2</I><DD>
If set to a nonempty string, a backup copy of the recovery log
goes in metadata_root/log_dir2.  The log_dir2 must end with "/"
if not empty.
<DT><I>master_hint</I><DD>
Specifies the "hint" to be placed in the "master-repository" attribute
for objects mastered in the local repository.  (You can think of this
as the "public address" of the repository, which may be different than
the address local clients use to contact the repository.)  This string
can either be empty (in which case "master-repository" attributes will
not be set) or a host name and TCP port number in the format
<I>host</I><TT>:</TT><I>port</I>.
<DT><I>metadata_root</I><DD>
All files and directories in the underlying filesystem that are
needed by the repository server are named relative to metadata_root.
This value must begin and end with "/".  The repository server does a
<I>chdir()</I> to this directory.
<DT><I>min_auto_access_refresh_delay</I><DD>
The repository keeps information in memory about all known UNIX
user/group ids and their mappings to global names. (See
<A HREF="repository.8.html#Principal identification and authentication">"Principal
identification and authentication"</A> above.)  If the repository
receives an NFS request with a user/group id which is unknown to it,
it will attempt to automatically reload the user/group information
from the host operating system.  (This can happen if a new user has
been added to the system since the repository server was started.)
Reloading this information can be expensive, so there is a limit on
how often it will be done automatically.  This setting specifies the
minimum time between such automatic refresh attempts in seconds.  If
not set, it defaults to 3600 (1 hour).  This setting does not affect
refreshes explicitly requested with the
<A HREF="vaccessrefresh.8.html"><B>vaccessrefresh</B></A> utility.
<DT><I>mutable_sid_refcount_paranoia</I><DD>
Option for repository developers to turn on extra consistency checking
of the reference counts used to track mutable files within the mutable
root (<TT>/vesta-work</TT>).  The two possible settings are "abort" and
"correct".  If set to "abort", the repository will die immediately
with a fatal error if any inconsistency is detected.  If set to
"correct", the repository will print an error message and correct the
inconsistency.
<DT><I>NFS_host</I><DD>
Host from which NFS service is exported.  This must be the host on
which the <B>repository</B> process is running.
<DT><I>NFS_port</I><DD>
UDP port on which NFS service is exported.
<DT><I>post_delete_weed_hook</I><DD>
An optional command to run after files are deleted by weeding.  See
the "<A HREF="repository.8.html#Weeding Hooks">Weeding Hooks</A>" section above.
<DT><I>pre_delete_weed_hook</I><DD>
An optional command to run before files are deleted by weeding.  See
the "<A HREF="repository.8.html#Weeding Hooks">Weeding Hooks</A>" section above.
<DT><I>realm</I><DD>
Name of the local access control realm.
When translating numeric Unix user and group identifiers received 
through the NFS interface into global names,
the repository first converts the numeric id to a name using values
from the local /etc/passwd and /etc/group files (or equivalent),
then appends <TT>@</TT><I>realm</I> to the local name.
In addition, the character "^" is used as a prefix for global group names
to distinguish them more clearly from user names.
<DT><I>restrict_delete</I><DD>
If this parameter is set to 1, 
the NFS interface restricts the delete and rename operations in
an appendable directory to the system administrator; if 0, they are
available to the directory's owner.
<DT><I>root_user</I><DD>
The user with this global name has system administrator access
permission to the repository.  The root user has complete access
permission to all files and directories in the repository, but cannot
violate their defined properties; for example, even he cannot modify
immutable files and directories.  This value is normally set to
<TT>root@</TT><I>realm</I>.
<DT><I>runtool_user</I><DD>
This user owns the roots of all volatile directory trees.  In fact,
because children of volatile and evaluator directories do not have
attributes, they always inherit this user as their owner.  This user
should not be made the owner of anything in the appendable and mutable
directory trees.  A typical setting for this value would be
<TT>vruntool@</TT><I>realm</I>.
<DT><I>ShortIdBlock_lease_period</I><DD>
One of the functions provided by the ShortId SRPC interface is the
right to allocate shortids out of a block of 256 shortids.  When a
client (the evaluator or weeder) acquires a shortid block, it has
exclusive rights to allocate unused shortids from that block for a
period of time which can be controlled by this setting.  If set it
must be a number of seconds that new shortid block leases will be
valid. If not set it defaults to 7200 seconds (2 hours).  It has a
hard minimum of 120 seconds (2 minutes). Normally there is no reason
to change this setting.
<DT><I>ShortIdSRPC_host</I><DD>
Host from which ShortIdSRPC is exported.  This must be the host on
which the <B>repository</B> process is running.
<DT><I>ShortIdSRPC_max_running</I><DD>
Maximum number of ShortId SRPC requests being serviced at
once. This parameter is optional.  If it's not set, it defaults to 32.
<DT><I>ShortIdSRPC_port</I><DD>
UDP port on which the SRPC interface that supports SourceOrDerived is
exported.
<DT><I>ShortIdSRPC_read_timeout</I><DD>
Maximum number of seconds the server will wait for data from a client
during a ShortId SRPC requests.  This prevents the server from
waiting indefinitely for suspended or misbehaving clients.  If it's
not set, it defaults to 300 (5 minutes).  (Note that the time between
individual calls on a connection can be longer than this.)
<DT><I>sid_dir</I><DD>
The directory tree rooted at metadata_root/sid_dir is used to store
source and derived files, with names derived from their ShortIds.
The sid_dir must end with "/" (or be empty).
<DT><I>threads</I><DD>
Sets the number of threads to be forked by the NFS server.
Zero means to use the process's main thread only.
<DT><I>umask</I><DD>
The repository sets its file mode creation mask (umask) to the given
value.  The default is 022.
<DT><I>vadmin_user</I><DD>
The user with this global name has system administrator access
permission to the repository.  Also, this user owns the appendable
root and mutable root unless they have explicit <TT>#owner</TT>
attributes.  The vadmin user has the same permissions as root, except
that (1) vadmin cannot create setuid or setgid files that are owned by
other users or groups, and (2) through the NFS interface, vadmin
cannot read or write files or directories that he does not have
permission for according to the ordinary permission bits, but he can
freely chmod or chown any file or directory to grant himself access.
The conventional setting for this value is <TT>vadmin@</TT><I>realm</I>.
<DT><I>vadmin_group</I><DD>
This global group is the owning group of the appendable root,
mutable root, and the roots of all volatile directory trees unless
they have explicit <TT>#group</TT> attributes.
A typical setting for this value might be <TT>^vadmin@</TT><I>realm</I>.
<DT><I>VestaSourceSRPC_host</I><DD>
Host from which VestaSourceSRPC is exported.  This must be the host on
which the <B>repository</B> process is running.
<DT><I>VestaSourceSRPC_max_running</I><DD>
Maximum number of VestaSource SRPC requests being serviced at
once. This parameter is optional.  If it's not set, it defaults to 32.
<DT><I>VestaSourceSRPC_port</I><DD>
UDP port on which the SRPC interface that supports VDirSurrogate and
related classes is exported.
<DT><I>VestaSourceSRPC_read_timeout</I><DD>
Maximum number of seconds the server will wait for data from a client
during a VestaSource SRPC requests.  This prevents the server from
waiting indefinitely for suspended or misbehaving clients.  If it's
not set, it defaults to 300 (5 minutes).  (Note that the time between
individual calls on a connection can be longer than this.)
<DT><I>vforeign_uid</I><DD>
A numeric Unix user id.
If none of the values of a source's <TT>#owner</TT> attribute is
of the form <I>user</I><TT>@</TT><I>realm</I>, where <I>realm</I> is the
local realm as defined above and <I>user</I> is a locally known user,
then when viewed through the NFS interface, the source's owner 
appears to be <I>vforeign_uid</I>.
Typically, one would define a special local Unix user named <TT>vforeign</TT>
for this purpose, and set this value to that user's uid.
<DT><I>vforeign_gid</I><DD>
A numeric Unix group id.
If none of the values of a source's <TT>#group</TT> attribute is
of the form <TT>^</TT><I>group</I><TT>@</TT><I>realm</I>, where <I>realm</I> is the
local realm as defined above and <I>group</I> is a locally known group,
then when viewed through the NFS interface, the source's group
appears to be <I>vforeign_gid</I>.
Typically, one would define a special local Unix group named <TT>vforeign</TT>
for this purpose, and set this value to that group's gid.
<DT><I>VMemPool_base</I><DD>
Address where the memory pool should be mmap'ed.  This memory must
remain contiguous as the pool grows, so a large address should be
chosen, well above any other memory that may be allocated.  A typical
choice would be 0x26600000000.  The default is to pass NULL to mmap
and let it choose an address, but this does not work well; mmap does
not guarantee it will be able to extend the resulting block contiguously.
<DT><I>VMemPool_minGrowBy</I><DD>
Minimum amount to grow the memory pool when it fills.
The default is one machine page.  A larger size is preferable, say
0x80000 (1/2 megabyte).
<DT><I>VMemPool_size</I><DD>
Initial size of the repository's internal memory pool.
The default is one machine page.  A larger size is preferable, say
0x100000 (one megabyte).
<DT><I>VMemPool_size_soft_limit</I><DD>
The repository's internal memory pool has a hard maximum size of
2^32-1 (0xffffffff) bytes.  If that limit is reached it could be
difficult to recover.  For that reason a lower soft limit is placed on
the maximum size to call attention when the hard limit is not far off.
The soft limit can then be raised, the repository can be brought back
up, deletions can be performed, and the weeder can be run to reclaim
space.  This setting controls the soft limit and defaults to 3.8 GB
(0xf0000000 bytes).
<DT><I>vwizard_user</I><DD>
The user with this global name has the same privileges as vadmin, but
is also allowed to perform agreement operations, such as deleting
children of master appendable directories without leaving a ghost,
creating children in nonmaster appendable directories, etc.  Except
for the initial creation of a globally unique name under /vesta for
packages that originate at your site (see <A HREF="repository.8.html#Warning">warning</A>
below), the vwizard feature should be used only in emergencies, since
it can create inconsistencies between replicas.  A typical setting for
this value would be <TT>vwizard@</TT><I>realm</I>.
</DL>
<P>

The following users, groups, files, and directories must be present to
run the repository.<P>

Users <I>[Repository]root_user</I>, <I>[Repository]vadmin_user</I>,
<I>[Repository]runtool_user</I>, and <I>[Repository]vforeign_uid</I> must
exist and must all be distinct.  User root_user should be root,
vadmin_user should be a special account for vesta administration, and
everyone_user should be a dummy account with logins disabled.  User
vforeign_uid should probably also have logins disabled. Users who need
access to sources replicated from a repository in another realm and
with no local owner defined could be allowed to su to it, but it's
probably better to add a local owner to the owner access control list
of such sources.<P>

Groups <I>[Repository]vadmin_group</I> and <I>[Repository]vforeign_gid</I>
must exist and must be distinct.  Group vadmin_group may be a special
group for vesta administration, or some standard system group (such as
group 0) may be used.  Users who need privileged access to sources
replicated from a repository in another realm could be made members of
vforeign_group, but it's probably better to add a local group to the
group access control list of such sources.<P>

The filenames 
<I>[Repository]group_file</I>,
<I>[Repository]alias_file</I>, and
<I>[Repository]export_file</I> must all be defined, but they need not
all exist.  However, if the export file is empty or does not exist,
no client hosts will have permission to access the repository.<P>

The repository server must not be run by root!  User 
<I>[Repository]vadmin_user</I> can
run it, or another user can be chosen.<P>

The directory configured as <I>[Repository]metadata_root</I> must exist
and must be writable by the user who will be running the repository
server.  So must its subdirectories <I>[Repository]log_dir</I> and
<I>[Repository]sid_dir</I>.  This directory tree must be used by only
one repository process at a time; the repository uses file locking
on its log to ensure this.<P>

The directories configured as
<I>[UserInterface]AppendableRootName</I> and 
<I>[UserInterface]MutableRootName</I> must exist and must be owned
by the user who will be mounting the repository
(if root will not be mounting it).
Normally these directories must be created separately on every
Vesta client machine because they are on a non-shared filesystem ("/").<P>

After the repository is started and mounted for the first
time, the following directories must be created, with access permissions
as described.  
You create these directories and set their permissions in the
ordinary way with "mkdir" and "chmod";
you may of course need to "su" to root or to
Vesta administrator (<I>[Repository]vadmin_user</I>) to be able to do this.
<DL>
<DT><I>[UserInterface]DefaultPackageParent</I><DD>
The default directory to put new packages in. 
Ordinarily a subdirectory of the appendable root, named with an Internet 
domain name belonging to the repository's owner.
See the warning below about creating new names under the appendable root.
Must be writable by
users who will be creating packages here.  After creating this
directory, you should also "cd" to it and type
the command "vattrib -s type package-parent", which tells
<A HREF="vcreate.1.html"><B>vcreate</B>(1)</A> 
that it is okay to create packages in it.
<DT><I>[UserInterface]DefaultWorkParent</I><DD>
The default parent directory for mutable working directory trees
belonging to individual users.  Typically the same 
as <I>[UserInterface]MutableRootName</I> (that is, /vesta-work), 
in which case it already exists.
If you choose to make this directory writable by all Vesta users, 
<A HREF="vcheckout.1.html"><B>vcheckout</B>(1)</A> will
automatically create a subdirectory under it for each user when that
user first checks out a package; if not, you will have to create those
subdirectories by hand.
<DT><I>[UserInterface]TempDir</I><DD> A temporary directory used by the
repository tools.  Typically <TT>/vesta-work/.tmp</TT>.  Must
be writable by all Vesta users.
<DT><I>[Run_Tool]VolatileRootName</I><DD> A directory used as the mount
point for the repository's volatile directory tree.
Typically <TT>/vesta-work/.volatile</TT>.
Must be readable and writable by the user(s) who will be mounting the
repository.
</DL>
<P>

<A NAME="Warning">Warning</A>:
Every name created directly under /vesta (more precisely,
directly under <I>[UserInterface]AppendableRootName</I>) must be
globally unique across all repositories in the universe in the past,
present, or future.  If you break this rule, your repository will have
problems participating in the replication protocol with those
repositories that have conflicting names.  We strongly recommend that
every name you create in this directory be an Internet domain name
that belongs to you; if everyone does so, uniqueness is guaranteed.
Do not reuse a name unless you are certain that the previous use of
the name has been permanently deleted in all repository replicas,
including replicas that might be recreated from backup media or the like.<P>

Note: If you do not have a registered domain name of your own, a good
alternative is to use a working email address that you intend to keep
permanently.  Change the "<TT>@</TT>" to "<TT>_</TT>" so that the name will not
have to be quoted when used in the <TT>import</TT> section of a Vesta
model.  For example, if you are an ACM member and have registered the
address <TT>johnsmith@acm.org</TT>, you could create the Vesta name
<TT>/vesta/johnsmith_acm.org</TT> without fear of causing a naming conflict.
This works because "<TT>_</TT>" is not a legal character in domain names.
</BLOCKQUOTE>

<H3><A NAME="See_Also">See Also</A></H3>
<BLOCKQUOTE>
<P>

<A HREF="vesta-intro.1.html"><B>vesta-intro</B>(1)</A>,
<A HREF="repos-ui.1.html"><B>repos-ui</B>(1)</A>,
<A HREF="mountrepos.8.html"><B>mountrepos</B>(8)</A>,
<A HREF="umountrepos.8.html"><B>umountrepos</B>(8)</A>,
<A HREF="vmount.8.html"><B>vmount</B>(8)</A>,
<A HREF="vaccessrefresh.8.html"><B>vaccessrefresh</B>(8)</A>,
<A HREF="vreposmonitor.8.html"><B>vreposmonitor</B>(8)</A>
</BLOCKQUOTE>

<H3><A NAME="Author">Author</A></H3>
<BLOCKQUOTE>
<P>

<A HREF="http://www.tim-mann.org/">Tim Mann</A>
</BLOCKQUOTE>

This page was generated automatically by
<A HREF="../../../mtex/index.html">mtex software</A>.
</BODY>
</HTML>
