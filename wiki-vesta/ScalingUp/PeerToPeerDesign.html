<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="robots" content="index,nofollow">

<title>ScalingUp/PeerToPeerDesign - Vesta Wiki</title>
<script type="text/javascript" src="../moin_static199/common/js/common.js"></script>

<script type="text/javascript">
<!--
var search_hint = "Search";
//-->
</script>


<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="../moin_static199/vesta/css/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="../moin_static199/vesta/css/screen.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="print" href="../moin_static199/vesta/css/print.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="projection" href="../moin_static199/vesta/css/projection.css">

<!-- css only for MS IE6/IE7 browsers -->
<!--[if lt IE 8]>
   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="../moin_static199/vesta/css/msie.css">
<![endif]-->


<link rel="alternate" title="Vesta Wiki: ScalingUp/PeerToPeerDesign" href="PeerToPeerDesign%3Fdiffs=1&amp;show_att=1&amp;action=rss_rc&amp;unique=0&amp;page=ScalingUp%252FPeerToPeerDesign&amp;ddiffs=1.html" type="application/rss+xml">


<link rel="Start" href="FrontPage.html">
<link rel="Alternate" title="Wiki Markup" href="PeerToPeerDesign%3Faction=raw.html">
<link rel="Alternate" media="print" title="Print View" href="PeerToPeerDesign%3Faction=print.html">
<link rel="Up" href="ScalingUp.html">
<link rel="Appendix" title="autogenerated-4357524e74f975a89098dd2cc30de9156883e0ae.png" href="PeerToPeerDesign%3Faction=AttachFile&amp;do=view&amp;target=autogenerated-4357524e74f975a89098dd2cc30de9156883e0ae.png.html">
<link rel="Appendix" title="autogenerated-789bd472b55cc9f29980dd8a573c80cfd376422a.png" href="PeerToPeerDesign%3Faction=AttachFile&amp;do=view&amp;target=autogenerated-789bd472b55cc9f29980dd8a573c80cfd376422a.png.html">
<link rel="Appendix" title="delete.me.to.regenerate.images" href="PeerToPeerDesign%3Faction=AttachFile&amp;do=view&amp;target=delete.me.to.regenerate.images.html">
<link rel="Search" href="FindPage.html">
<link rel="Index" href="TitleIndex.html">
<link rel="Glossary" href="WordIndex.html">
<link rel="Help" href="HelpOnFormatting.html">
</head>

<body  lang="en" dir="ltr">

<div id="header">

<form id="searchform" method="get" action="PeerToPeerDesign.html">
<div>
<input type="hidden" name="action" value="fullsearch">
<input type="hidden" name="context" value="180">
<label for="searchinput">Search:</label>
<input id="searchinput" type="text" name="value" value="" size="20"
    onfocus="searchFocus(this)" onblur="searchBlur(this)"
    onkeyup="searchChange(this)" onchange="searchChange(this)" alt="Search">
<input id="titlesearch" name="titlesearch" type="submit"
    value="Titles" alt="Search Titles">
<input id="fullsearch" name="fullsearch" type="submit"
    value="Text" alt="Search Full Text">
</div>
</form>
<script type="text/javascript">
<!--// Initialize search form
var f = document.getElementById('searchform');
f.getElementsByTagName('label')[0].style.display = 'none';
var e = document.getElementById('searchinput');
searchChange(e);
searchBlur(e);
//-->
</script>

<div id="logo"><a href="FrontPage.html"><img src="wiki/vesta/img/1line.png" alt="Vesta" height=44 width=202></a></div>
<div id="locationline">

<ul id="pagelocation">
<li><a href="ScalingUp.html">ScalingUp</a></li><li><a href="PeerToPeerDesign.html">PeerToPeerDesign</a></li>
</ul>

</div>
</div>

<div id="sidebar">
<div class="sidepanel">
<h1>Wiki</h1>

<ul id="navibar">
<li class="wikilink"><a href="RecentChanges.html">RecentChanges</a></li><li class="wikilink"><a href="FindPage.html">FindPage</a></li><li class="wikilink"><a href="HelpContents.html">HelpContents</a></li><li class="current"><a href="PeerToPeerDesign.html">PeerToPeerDesign</a></li>
</ul>

</div>
<div class="sidepanel">
<h1>User</h1>
<ul id="username"><li><a href="PeerToPeerDesign%3Faction=login.html" id="login" rel="nofollow">Login</a></li></ul>
</div>
</div>

<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><span class="anchor" id="line-5"></span><p class="line867"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li>
<a href="PeerToPeerDesign.html#An_Opportunity">An Opportunity</a></li><li>
<a href="PeerToPeerDesign.html#Immutable_Shortid_Cache">Immutable Shortid Cache</a></li><li>
<a href="PeerToPeerDesign.html#Shortid_Availability_Tracking">Shortid Availability Tracking</a></li><li>
<a href="PeerToPeerDesign.html#Possible_Improvements">Possible Improvements</a><ol><li>
<a href="PeerToPeerDesign.html#Compression">Compression</a></li><li>
<a href="PeerToPeerDesign.html#Limiting_The_Size_of_the_Client_Cache">Limiting The Size of the Client Cache</a></li></ol></li><li>
<a href="PeerToPeerDesign.html#Implementation_Wrinkles">Implementation Wrinkles</a><ol><li>
<a href="PeerToPeerDesign.html#Weeding">Weeding</a></li><li>
<a href="PeerToPeerDesign.html#Client_Startup">Client Startup</a></li><li>
<a href="PeerToPeerDesign.html#Repository.2FTracker_Server_Restart">Repository/Tracker Server Restart</a></li><li>
<a href="PeerToPeerDesign.html#Small_Vesta_Installations">Small Vesta Installations</a></li><li>
<a href="PeerToPeerDesign.html#Tolerating_Flaky_Peers">Tolerating Flaky Peers</a></li></ol></li><li>
<a href="PeerToPeerDesign.html#Limited_Prototype">Limited Prototype</a><ol><li>
<a href="PeerToPeerDesign.html#Information_for_Users.2FAdministrators">Information for Users/Administrators</a></li></ol></li><li>
<a href="PeerToPeerDesign.html#Protocol_Notes">Protocol Notes</a><ol><li>
<a href="PeerToPeerDesign.html#Central_Tracker_Server">Central Tracker Server</a><ol><li>
<a href="PeerToPeerDesign.html#File_Request">File Request</a></li><li>
<a href="PeerToPeerDesign.html#Have_File">Have File</a></li><li>
<a href="PeerToPeerDesign.html#Drop_File">Drop File</a></li><li>
<a href="PeerToPeerDesign.html#Bad_Peer_Report">Bad Peer Report</a></li><li>
<a href="PeerToPeerDesign.html#Peer_Restart">Peer Restart</a></li><li>
<a href="PeerToPeerDesign.html#Block_Request">Block Request</a></li></ol></li><li>
<a href="PeerToPeerDesign.html#Caching_Agent">Caching Agent</a><ol><li>
<a href="PeerToPeerDesign.html#File_Request-1">File Request</a></li><li>
<a href="PeerToPeerDesign.html#File_Check">File Check</a></li><li>
<a href="PeerToPeerDesign.html#Weeding-1">Weeding</a></li></ol></li></ol></li></ol></div> <span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span><p class="line862">(This design borrows some ideas from <a class="http" href="http://en.wikipedia.org/wiki/BitTorrent">BitTorrent</a>.  You may want to read <a class="http" href="http://computer.howstuffworks.com/bittorrent.htm/printable">&quot;How BitTorrent Works&quot;</a> if you're not already familiar with that protocol.) <span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line862">(<a class="nonexistent" href="../JoeLee.html">JoeLee</a> deserves credit for first pointing out that the problem of distributing immutable files to a large number of clients is very similar to the problem BitTorrent was designed to solve.) <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line867">
<h1 id="An_Opportunity">An Opportunity</h1>
<span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span><p class="line874">A basic fact of a multi-client Vesta installation is that the contents of immutable files (both source and derived) exist on multiple hosts. <span class="anchor" id="line-14"></span><span class="anchor" id="line-15"></span><ul><li>When a source file is read by a tool during a build, its contents exist in the NFS client cache on the host running the tool. <span class="anchor" id="line-16"></span></li><li>When a derived file is written by a tool, the contents of the file exist in the NFS client on the host running the tool <span class="anchor" id="line-17"></span></li><li>When a build result shipped as symlinks is read by a client, the file's contents exist in the NFS client cache on the host using the build result <span class="anchor" id="line-18"></span><span class="anchor" id="line-19"></span></li></ul><p class="line874">Because we're using NFS to a single server (both to the repository's virtual filesystem and for the shortid pool which builds shipped as links point into), any client which does not have the contents of a file go through the server.  When there are many clients and lots of files being accessed, this can require a lot of server resources. <span class="anchor" id="line-20"></span><span class="anchor" id="line-21"></span><p class="line867"><span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span><span class="anchor" id="line-28"></span><span class="anchor" id="line-29"></span><span class="anchor" id="line-30"></span><span class="anchor" id="line-31"></span><span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><img src="PeerToPeerDesign%3Faction=AttachFile&amp;do=get&amp;target=autogenerated-789bd472b55cc9f29980dd8a573c80cfd376422a.png" /><span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span><p class="line874">The fact that so many files are immutable give us an opportunity for optimization.  If we change network protocols (i.s. stop having all clients access one central server via NFS), we could take advantage of the fact that the same data exists in multiple places.  When a client needs a file that another client already has, it could retrieve it from that client rather than from the central server. <span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><p class="line867"><span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><span class="anchor" id="line-42"></span><span class="anchor" id="line-43"></span><span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span><span class="anchor" id="line-48"></span><span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span><span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><span class="anchor" id="line-53"></span><span class="anchor" id="line-54"></span><span class="anchor" id="line-55"></span><span class="anchor" id="line-56"></span><span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span><span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span><span class="anchor" id="line-61"></span><span class="anchor" id="line-62"></span><span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span><span class="anchor" id="line-65"></span><span class="anchor" id="line-66"></span><span class="anchor" id="line-67"></span><span class="anchor" id="line-68"></span><span class="anchor" id="line-69"></span><span class="anchor" id="line-70"></span><span class="anchor" id="line-71"></span><span class="anchor" id="line-72"></span><span class="anchor" id="line-73"></span><img src="PeerToPeerDesign%3Faction=AttachFile&amp;do=get&amp;target=autogenerated-4357524e74f975a89098dd2cc30de9156883e0ae.png" /><span class="anchor" id="line-74"></span><span class="anchor" id="line-75"></span><p class="line867">
<h1 id="Immutable_Shortid_Cache">Immutable Shortid Cache</h1>
<span class="anchor" id="line-76"></span><span class="anchor" id="line-77"></span><p class="line874">The first step is to take control of the caching of immutable file contents on the client hosts.  (While the NFS client cache provides a similar capability, it's essentially opaque and outside our control, not least of all because there are multiple different NFS client implementations.) <span class="anchor" id="line-78"></span><span class="anchor" id="line-79"></span><p class="line874">We would want to use the same 32-bit shortids for identifying files as is used in the repository, evaluator, and build cache.  Also we would only cache the contents of immutable shortids on clients. <span class="anchor" id="line-80"></span><span class="anchor" id="line-81"></span><p class="line874">This local cache of immutable shortids would be made available on the client through a virtual filesystem.  There are at least two ways we would want to do this: <span class="anchor" id="line-82"></span><span class="anchor" id="line-83"></span><ul><li><p class="line862">As an alternative to accessing the shortid pool over normal NFS.  This would facilitate the evaluator's <a class="http" href="../../vesta/doc/man/html/vesta.1.html#-s">-s (ship as symlinks) flag</a>.  An attempt to access a shortid through this interface would trigger retrieval of the shortid contents. <span class="anchor" id="line-84"></span><ul><li><p class="line862">(Note that since this would only support immutable shortids, it would <em>not</em> work as a complete replacement for the current evaluator's access to the shortid pool over normal NFS, as that includes writing files.  We've already been working on changing the implementation to avoid the need for that.) <span class="anchor" id="line-85"></span></li></ul></li><li><p class="line862">For the volatile directories used when executing tools.  This would require moving the serving of volatile directories out of the central repository server and into the RunToolServer on each client. <span class="anchor" id="line-86"></span><ul><li><p class="line862">Locally caching the input files for each tool run could provide better performance than the current implementation.  The repository does actually play tricks with the NFS filehandles to try to take advantage of the NFS client read cache across multiple tool runs on the same host, but these can only be used under the right conditions (when the <tt>existing_writable</tt> argument to <tt>_run_tool</tt> is false) and we have no control over how much data is retained or for how long. <span class="anchor" id="line-87"></span></li><li>Keeping a cache of result files after they have been completely written would provide an alternate source for the file contents if a subsequent build step using it should run on a different client <span class="anchor" id="line-88"></span><span class="anchor" id="line-89"></span></li></ul></li></ul><p class="line874">Once a client has a copy of an immutable shortid, it would also make it available to peer clients. <span class="anchor" id="line-90"></span><span class="anchor" id="line-91"></span><p class="line867">
<h1 id="Shortid_Availability_Tracking">Shortid Availability Tracking</h1>
<span class="anchor" id="line-92"></span><span class="anchor" id="line-93"></span><p class="line862">The repository server would need to keep track of which clients have copies of what immutable shortids.  In <a class="http" href="http://en.wikipedia.org/wiki/BitTorrent">BitTorrent</a> terminology, it would act as a <a class="http" href="http://en.wikipedia.org/wiki/BitTorrent_tracker">tracker</a>. <span class="anchor" id="line-94"></span><span class="anchor" id="line-95"></span><p class="line874">When a client needs a copy of a shortid, it asks the repository server for a list of other peers which have it.  The server gives the client that list.  The client then contacts one of those peers to get a copy of the file. <span class="anchor" id="line-96"></span><span class="anchor" id="line-97"></span><p class="line874">The server should also give out additional information about the file (the timestamp, size, and checksum) so that the data retrieved from the peer can be validated. <span class="anchor" id="line-98"></span><span class="anchor" id="line-99"></span><p class="line874">In the event that no peer has the file, it obtains a copy directly from the server.  The server then remembers that the client has the file. <span class="anchor" id="line-100"></span><span class="anchor" id="line-101"></span><p class="line874">If a client contacts a peer to obtain a file and has trouble (connection refused or timed out, the peer claims not to have the file, the peer sends data with a bad checksum), it will inform the server so that it can be removed from the tracker. <span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><p class="line867">
<h1 id="Possible_Improvements">Possible Improvements</h1>
<span class="anchor" id="line-104"></span><span class="anchor" id="line-105"></span><p class="line874">There are a few things which would not be strictly necessary but which we may want to consider along with this. <span class="anchor" id="line-106"></span><span class="anchor" id="line-107"></span><p class="line867">
<h2 id="Compression">Compression</h2>
<span class="anchor" id="line-108"></span><span class="anchor" id="line-109"></span><p class="line874">This could actually help with implementing compression of the repository's file store.  One problem with compression is the significant additional CPU load it could place on the central repository server. <span class="anchor" id="line-110"></span><span class="anchor" id="line-111"></span><p class="line874">Since the clients would be mediating access to the shortids in most cases, we could have the decompression performed on the client end. <span class="anchor" id="line-112"></span><span class="anchor" id="line-113"></span><p class="line874">For derived files, if the volatile directory serving is performed on the clients and result files are only sent back to the server once they've been fully written, the client could compress them first.  This would distribute the compression work as well. <span class="anchor" id="line-114"></span><span class="anchor" id="line-115"></span><p class="line867">
<h2 id="Limiting_The_Size_of_the_Client_Cache">Limiting The Size of the Client Cache</h2>
<span class="anchor" id="line-116"></span><span class="anchor" id="line-117"></span><p class="line874">Suppose a client is running a tool that reads large number of files, or is using a build result shipped as links that contains many files.  Should it cache all of them locally?  That would probably be the most straight-forward approach, but that could result in a large amount of data being cached on each client and in many duplicate copies of the same file. <span class="anchor" id="line-118"></span><span class="anchor" id="line-119"></span><p class="line874">Another alternative would be to allow one client to perform read-through from a peer without caching its own copy.  We might also need to allow read-through directly from the server if we want to put a strict limit on the size of each client's cache. <span class="anchor" id="line-120"></span><span class="anchor" id="line-121"></span><p class="line874">Another way we might want to tune the caching is to set a target number of clients to cache each shortid.  If a client finds that fewer than the target number of clients have cached a shortid, then it would also cache a copy of it.  Otherwise it could do read-through from one of the clients that has a copy of it. <span class="anchor" id="line-122"></span><span class="anchor" id="line-123"></span><p class="line867">
<h1 id="Implementation_Wrinkles">Implementation Wrinkles</h1>
<span class="anchor" id="line-124"></span><span class="anchor" id="line-125"></span><p class="line874">There are a few tricky parts to implementing this. <span class="anchor" id="line-126"></span><span class="anchor" id="line-127"></span><p class="line867">
<h2 id="Weeding">Weeding</h2>
<span class="anchor" id="line-128"></span><span class="anchor" id="line-129"></span><p class="line874">When weeding occurs, each immutable shortid cache will need to perform the same shortid deletions as the repository server. <span class="anchor" id="line-130"></span><span class="anchor" id="line-131"></span><p class="line874">The repository would have to broadcast the set of shortids to keep and the associated keep time to all clients running an immutable shortid cache.  They would then each need to drop and shortids not on that list and older than the keep time. <span class="anchor" id="line-132"></span><span class="anchor" id="line-133"></span><p class="line867"><em>This means that clients will <strong>need to keep the correct modification time</strong> of immutable shortids in addition to their contents.</em> <span class="anchor" id="line-134"></span><span class="anchor" id="line-135"></span><p class="line867">
<h2 id="Client_Startup">Client Startup</h2>
<span class="anchor" id="line-136"></span><span class="anchor" id="line-137"></span><p class="line874">When a client starts up its immutable shortid cache, it has no way to know whether a weed has happened since it was last running.  This means that some of the immutable shortids it cached locally when it was last running may no longer be valid. <span class="anchor" id="line-138"></span><span class="anchor" id="line-139"></span><p class="line867"><strong>Therefore, it must discard all previously cached immutable shortids.</strong> <span class="anchor" id="line-140"></span><span class="anchor" id="line-141"></span><p class="line867"><em>Well, we could improve on that some.  The repository could keep a weed generation number, incremented each time a weed is done.  Then if we're still in the same generation number when a client starts/restarts as when the client last ran, the client can keep its cache. --<a href="../TimMann.html">TimMann</a></em> <span class="anchor" id="line-142"></span><span class="anchor" id="line-143"></span><p class="line867">
<h2 id="Repository.2FTracker_Server_Restart">Repository/Tracker Server Restart</h2>
<span class="anchor" id="line-144"></span><span class="anchor" id="line-145"></span><p class="line874">If the repository server restarts, what are the consequences for the immutable shortid cache? <span class="anchor" id="line-146"></span><span class="anchor" id="line-147"></span><p class="line874">It's tempting to think that it can keep the files it had cached before the server went down and simply reconnect and send the set of files it has to re-initialize the tracker.  However there could be a race between clients reconnecting and weeding which would leave some with invalid shortids cached. <span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><p class="line874">A conservative approach would be to simply drop all cached shortids when the repository server restarts.  However it would be nice if we didn't have to invalidate the entire cache. <span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><p class="line874">Another possibility would be to have the client when reconnecting with the restarted server have its set of currently cached shortids re-validated.  This could be done through a checksum of the contents of each (plus the timestamp which we know needs to be kept for weeding). <span class="anchor" id="line-152"></span><span class="anchor" id="line-153"></span><p class="line874">Note that in order to implement this, the local caching agent will need to pay careful attention to network errors when communicating with the repository/tracker server. <span class="anchor" id="line-154"></span><span class="anchor" id="line-155"></span><p class="line867"><em>Same comment here as on client startup above.  --<a href="../TimMann.html">TimMann</a></em> <span class="anchor" id="line-156"></span><span class="anchor" id="line-157"></span><p class="line867">
<h2 id="Small_Vesta_Installations">Small Vesta Installations</h2>
<span class="anchor" id="line-158"></span><span class="anchor" id="line-159"></span><p class="line874">It's possible to run Vesta with a small number of clients, even a single machine installation.  Some people run Vesta on laptops. <span class="anchor" id="line-160"></span><span class="anchor" id="line-161"></span><p class="line874">We definitely need to ensure that there's some way to disable client-side caching of shortids when the client and server are the same machine.  We should probably also allow it to be turned off for installations with a small number of clients, or for clients with resource restrictions (e.g. a lack of disk to use for locally caching immutable shortids). <span class="anchor" id="line-162"></span><span class="anchor" id="line-163"></span><p class="line874">Assuming that we allow read-through from the server when limiting the size of each clients cache, we could simply set the maximum client cache size to zero for the single-host case, switching it always read through from the server.  We would want to ensure that the read-through from the server was very efficient to try and avoid degrading performance in the single-host case. <span class="anchor" id="line-164"></span><span class="anchor" id="line-165"></span><p class="line867"><span class="anchor" id="flaky_peers"></span> <span class="anchor" id="line-166"></span>
<h2 id="Tolerating_Flaky_Peers">Tolerating Flaky Peers</h2>
<span class="anchor" id="line-167"></span><span class="anchor" id="line-168"></span><p class="line874">What if a peer falls off the network?  What if it is heavily loaded such that it has difficulty serving out a file?  What if it accepts the connection but never answers the RPC requesting the file?  (Some versions of the Linux kernel can get wedged and do this, apparently never scheduling the listening process.) <span class="anchor" id="line-169"></span><span class="anchor" id="line-170"></span><p class="line874">We need to take care to make sure we tolerate cases like this. <span class="anchor" id="line-171"></span><span class="anchor" id="line-172"></span><p class="line874">One way we might do this is have a client send requests to multiple peers that have a copy of a file.  If a client was going to cache a copy of a shortid, it could ask one peer for the first half of the file and another for the second half of the file in parallel (i.e. in two different threads).  If one of them has failed to respond by the time the other has, then it could be declared dead.  One could even use more peers and smaller pieces of the file for large files. <span class="anchor" id="line-173"></span><span class="anchor" id="line-174"></span><p class="line874">However, if a file is retrieved piecmail and re-assembled and then turns out to have an incorrect checksum, it could be tricky to determine which piece or pieces of the file were bad.  There are methods for dealing with this (hash tries, and I believe rsync has a method for determining which portion of a file is different) which we might need to use. <span class="anchor" id="line-175"></span><span class="anchor" id="line-176"></span><p class="line867">
<h1 id="Limited_Prototype">Limited Prototype</h1>
<span class="anchor" id="line-177"></span><span class="anchor" id="line-178"></span><p class="line862">We could build a relatively limited prototype version of this that runs separately from the repository.  The server side would implement the tracker functionality and serve out copies of any shortids that are already immutable (based on their on-disk permission bits).  The client side would present a virtual filesystem that's equivalent the <tt>sid</tt> directory and perform local caching of immutable shortids. <span class="anchor" id="line-179"></span><span class="anchor" id="line-180"></span><p class="line874">This would only be useful for a read-only shortid pool that could be pointed to by a build shipped as symlinks.  However the server and client sides could be separate from the Vesta repository. <span class="anchor" id="line-181"></span><span class="anchor" id="line-182"></span><p class="line874">The only code change which would be necessary would be adding a feature to the evaluator which would change the shortid directory that results shipped as symlinks pointed into. <span class="anchor" id="line-183"></span><span class="anchor" id="line-184"></span><p class="line874">This would lack some advantages of a more complete solution.  It would not provide any speedup for running tools during building.  Building would also not automatically seed the client running the tool with a copy of the derived files it writes.  However it would be significantly easier to put this together and could allow us to get a rough idea of how effective the technique would be. <span class="anchor" id="line-185"></span><span class="anchor" id="line-186"></span><p class="line874">Weeding would be a minor problem.  We would probably need to force a restart of the server end when weeding, using one of the methods described above for handling server restart. <span class="anchor" id="line-187"></span><span class="anchor" id="line-188"></span><p class="line874">We now have the beginning of such a prototype: <span class="anchor" id="line-189"></span><span class="anchor" id="line-190"></span><p class="line867"><a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/beta.vestasys.org/vesta/extras/p2p_sid_prototype">/vesta/beta.vestasys.org/vesta/extras/p2p_sid_prototype</a> <span class="anchor" id="line-191"></span><span class="anchor" id="line-192"></span><p class="line867"><span class="anchor" id="admin_info"></span> <span class="anchor" id="line-193"></span><span class="anchor" id="line-194"></span><p class="line867">
<h2 id="Information_for_Users.2FAdministrators">Information for Users/Administrators</h2>
<span class="anchor" id="line-195"></span><span class="anchor" id="line-196"></span><p class="line874">The main decisions you need to make are: <span class="anchor" id="line-197"></span><span class="anchor" id="line-198"></span><ul><li><p class="line862">Where will the file caching agent store its local copies on each machine?  You specify this with the <tt>[ShortidCache]dir</tt> setting in <tt>vesta.cfg</tt>.  If <tt>/tmp</tt> has enough space, you can just put it there.  <em>(Make sure you pick a directory local to each machine.)</em>  Nothing needs to be saved across reboots or restarts of the file caching agent.  It will work just fine if you delete the files it places there (while it's not running). <span class="anchor" id="line-199"></span></li><li><p class="line862">How much disk space do you want it to use for local cached copies of files?  You specify this with the <tt>[ShortidCache]disk_limit</tt> setting in <tt>vesta.cfg</tt>.  You can give a number of bytes with an optional multiplier (k, M, G) or as a percentage of the total size of the filesystem containing the local cache.  If not set, it defaults to &quot;10%&quot;.  (If you pick a size larger than the space available on the disk, the file caching agent will still do its best not to fill it up completely.) <span class="anchor" id="line-200"></span></li><li><p class="line862">Where do you want to mount the virtual filesystem provided by the file caching agent?  You specify this with the <tt>[ShortidCache]mount</tt> setting in <tt>vesta.cfg</tt>.  Normally you and should make this end in &quot;/sid&quot; and set <tt>[Evaluator]symlink_sid_root</tt> to the part before the &quot;/sid&quot; for users who want to use the file caching agent with builds shipped as symlinks.  (You'll need an evaluator with support for <tt>[Evaluator]symlink_sid_root</tt> to use this.  <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/vesta/release/12.pre13/10">release/12.pre13/10</a> was the first pre-release to include that feature.)  For example: <span class="anchor" id="line-201"></span><ul><li><p class="line891"><tt>[ShortidCache]mount</tt> = &quot;<tt>/tmp/.p2p-vesta/sid</tt>&quot; <span class="anchor" id="line-202"></span></li><li><p class="line891"><tt>[Evaluator]symlink_sid_root</tt> = &quot;<tt>/tmp/.p2p-vesta</tt>&quot; <span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span></li></ul></li></ul><p class="line862">See <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/beta.vestasys.org/vesta/extras/p2p_sid_prototype/latest/examples">the &quot;examples&quot; directory in the package of the prototype implementation</a>.  In there you'll find: <span class="anchor" id="line-205"></span><span class="anchor" id="line-206"></span><ul><li><p class="line891"><a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/beta.vestasys.org/vesta/extras/p2p_sid_prototype/latest/examples/vesta.cfg">A sample vesta.cfg</a> with explanations of all the settings <span class="anchor" id="line-207"></span></li><li><p class="line891"><a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/beta.vestasys.org/vesta/extras/p2p_sid_prototype/latest/examples/etc/init.d/sid_agent">A script to start the file caching agent and mount it automatically at boot time</a> and <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/beta.vestasys.org/vesta/extras/p2p_sid_prototype/latest/examples/etc/vesta/sid_agent_config">a file of settings to control the boot-time script</a> <span class="anchor" id="line-208"></span><span class="anchor" id="line-209"></span><span class="anchor" id="line-210"></span></li></ul><p class="line867">
<h1 id="Protocol_Notes">Protocol Notes</h1>
<span class="anchor" id="line-211"></span><span class="anchor" id="line-212"></span><p class="line862">This section contains some notes on the different network protocols needed to implement this.  Unless we have a reason to do something different, these will be implemented over TCP as remote procedure call protocols using <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/vesta/srpc">the SRPC library</a> which is used by other components of Vesta. <span class="anchor" id="line-213"></span><span class="anchor" id="line-214"></span><p class="line862">For comparison and reference: <a class="http" href="http://wiki.theory.org/BitTorrentSpecification">the BitTorrent protocol specification</a>. <span class="anchor" id="line-215"></span><span class="anchor" id="line-216"></span><p class="line867">
<h2 id="Central_Tracker_Server">Central Tracker Server</h2>
<span class="anchor" id="line-217"></span><span class="anchor" id="line-218"></span><p class="line874">This protocol will be used by the peer file caching agents to communicate with the central server.  It's used for: <span class="anchor" id="line-219"></span><span class="anchor" id="line-220"></span><ul><li>The initial download of a file when no peers can provide a copy <span class="anchor" id="line-221"></span></li><li>Maintaining the lists of peers which have copies of each file <span class="anchor" id="line-222"></span></li><li>Allowing one peer to locate other peers which have the files it needs <span class="anchor" id="line-223"></span><span class="anchor" id="line-224"></span></li></ul><p class="line867">
<h3 id="File_Request">File Request</h3>
<span class="anchor" id="line-225"></span><span class="anchor" id="line-226"></span><p class="line874">This is a request from a client for a file which they need. <span class="anchor" id="line-227"></span><span class="anchor" id="line-228"></span><p class="line874">Client sends: <span class="anchor" id="line-229"></span><span class="anchor" id="line-230"></span><ol type="1"><li>The shortid they need. <span class="anchor" id="line-231"></span></li><li>The port they listen on for requests from peers <span class="anchor" id="line-232"></span><ul><li>The IP address from the client end of the RPC is combined with the port for a full address <span class="anchor" id="line-233"></span><span class="anchor" id="line-234"></span></li></ul></li></ol><p class="line874">Server responds with: <span class="anchor" id="line-235"></span><span class="anchor" id="line-236"></span><ol type="1"><li><p class="line862">The type of response, which is one of: <strong>No Such File</strong>, <strong>File Contents</strong>, or <strong>Peer Set</strong> <span class="anchor" id="line-237"></span><ul><li><p class="line862">If the response is <strong>No Such File</strong> no other data is sent <span class="anchor" id="line-238"></span></li><li><p class="line862">If the response is <strong>File Contents</strong>, the server then sends: <span class="anchor" id="line-239"></span><ol type="1"><li>File attributes <span class="anchor" id="line-240"></span><ul><li>Size in bytes <span class="anchor" id="line-241"></span></li><li>Modification time <span class="anchor" id="line-242"></span></li><li>Executable flag <span class="anchor" id="line-243"></span></li></ul></li><li>A data block size <span class="anchor" id="line-244"></span></li><li>A sequence of blocks (the entire file), each with: <span class="anchor" id="line-245"></span><ul><li>A block hash (currently using the fingerprinting algorithm used by other parts of Vesta) <span class="anchor" id="line-246"></span></li><li>A sequence of bytes (the data in the block) <span class="anchor" id="line-247"></span></li></ul></li></ol></li><li><p class="line862">If the response is <strong>Peer Set</strong>, the server then sends: <span class="anchor" id="line-248"></span><ol type="1"><li><p class="line862">A sequence of peer addresses, each as IPv4 <tt>IP:port</tt> addresses <span class="anchor" id="line-249"></span></li><li>File attributes <span class="anchor" id="line-250"></span><ul><li>Size in bytes <span class="anchor" id="line-251"></span></li><li>Modification time <span class="anchor" id="line-252"></span></li><li>Executable flag <span class="anchor" id="line-253"></span></li></ul></li><li>A data block size <span class="anchor" id="line-254"></span></li><li>A sequence of block hashes <span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span></li></ol></li></ul></li></ol><p class="line862">The server chooses to send the file contents when the number of clients it knows of is below a certain threshold (defaulting to 3).  This ensures that when the server responds with a peer set that there are multiple peers for the client to contact.  (See <a href="PeerToPeerDesign.html#flaky_peers">Tolerating Flaky Peers</a> above.) <span class="anchor" id="line-257"></span><span class="anchor" id="line-258"></span><p class="line862">A <a class="http" href="http://en.wikipedia.org/wiki/Hash_list">hash list</a> is used to allow clients to independently verify individual data blocks retrieved from peers.  The server chooses the block size which clients must then use when communicating with peers.  (Note that small files may be just one block.) <span class="anchor" id="line-259"></span><span class="anchor" id="line-260"></span><p class="line874">When sending file contents directly, the block hashes are sent as part of the sequence of block data.  (That is, the first block hash arrives , followed by the first block's data, followed by the second block hash, followed by the second block's data, and so on.)  This allows the server to compute the block hashes as it sends each block, avoiding the need to read the entire file twice. <span class="anchor" id="line-261"></span><span class="anchor" id="line-262"></span><p class="line874">If the server chooses to send the file contents, it immediately adds the clients address to the set of peers believed to have a copy of the file so that it can give their address to other clients requesting the file. <span class="anchor" id="line-263"></span><span class="anchor" id="line-264"></span><p class="line867">
<h3 id="Have_File">Have File</h3>
<span class="anchor" id="line-265"></span><span class="anchor" id="line-266"></span><p class="line874">This is an indication from a client that they have retrieved a file from their peers and request to be added to the tracker so that other clients can get the file from them. <span class="anchor" id="line-267"></span><span class="anchor" id="line-268"></span><p class="line874">Client sends: <span class="anchor" id="line-269"></span><span class="anchor" id="line-270"></span><ol type="1"><li>The shortid they have <span class="anchor" id="line-271"></span></li><li>The port where other peers can call them to retrieve it <span class="anchor" id="line-272"></span><ul><li>The IP address from the client end of the RPC is saved with the port <span class="anchor" id="line-273"></span></li></ul></li><li>File attributes <span class="anchor" id="line-274"></span><ul><li>Size in bytes <span class="anchor" id="line-275"></span></li><li>Modification time <span class="anchor" id="line-276"></span></li><li>Executable flag <span class="anchor" id="line-277"></span></li></ul></li><li>A data block size <span class="anchor" id="line-278"></span></li><li>A sequence of block hashes <span class="anchor" id="line-279"></span><span class="anchor" id="line-280"></span></li></ol><p class="line874">The server responds with a boolean indicating whether the client was added to the set of peers believed to have a copy of the file.  Obviously the server will only add the client if the file attributes and block hashes sent match the information which the server has about the file. <span class="anchor" id="line-281"></span><span class="anchor" id="line-282"></span><p class="line874">A well-behaved client is obligated to discard its copy of the file and not provide its contents to peer if the server indicates a mis-match. <span class="anchor" id="line-283"></span><span class="anchor" id="line-284"></span><p class="line874">It is possible that the server has no record of the file and yet the client's copy is valid.  This could be cause by a race between all the peers the server knows of dropping the file and the client that just obtained a copy from them telling the server that is has a copy of it.  The server could read the file from disk and check the block hashes to validate the client's copy, or it could simply respond in the negative and force the client to re-request the file. <span class="anchor" id="line-285"></span><span class="anchor" id="line-286"></span><p class="line874">Note that the client does not need to make this call when the server immediately sends a file to them in response to a file request.  In that case, the server automatically adds the client to the known peer set. <span class="anchor" id="line-287"></span><span class="anchor" id="line-288"></span><p class="line867">
<h3 id="Drop_File">Drop File</h3>
<span class="anchor" id="line-289"></span><span class="anchor" id="line-290"></span><p class="line874">This is an indication from a client that they are discarding a file from their local cache and will no longer be able to provide its contents to other peers. <span class="anchor" id="line-291"></span><span class="anchor" id="line-292"></span><p class="line874">Client sends: <span class="anchor" id="line-293"></span><span class="anchor" id="line-294"></span><ol type="1"><li>The shortid they are discarding from the local cache <span class="anchor" id="line-295"></span></li><li>The port where other peers can call them to retrieve it <span class="anchor" id="line-296"></span><ul><li>As with the &quot;File Request&quot; and &quot;Have File&quot; calls, the IP address from the client end of the RPC is combined with the port to get a full address <span class="anchor" id="line-297"></span><span class="anchor" id="line-298"></span></li></ul></li></ol><p class="line862">The server response is empty.  (It could send an error if the <tt>IP:port</tt> was not in the tracker for the file, but it can also just ignore that case.) <span class="anchor" id="line-299"></span><span class="anchor" id="line-300"></span><p class="line867">
<h3 id="Bad_Peer_Report">Bad Peer Report</h3>
<span class="anchor" id="line-301"></span><span class="anchor" id="line-302"></span><p class="line874">This is an indication from a client that they contacted another peer with a file requests and either they said they didn't have it or a network error prevented the request. <span class="anchor" id="line-303"></span><span class="anchor" id="line-304"></span><p class="line874">Client sends: <span class="anchor" id="line-305"></span><span class="anchor" id="line-306"></span><ol type="1"><li>The shortid they were looking for <span class="anchor" id="line-307"></span></li><li><p class="line862">The peer <tt>IP:port</tt> they tried but couldn't get it from <span class="anchor" id="line-308"></span><span class="anchor" id="line-309"></span></li></ol><p class="line862">Server response is empty.  Note that the server responds immediately and queues this shortid/<tt>IP:port</tt> to be checked in the background <span class="anchor" id="line-310"></span><span class="anchor" id="line-311"></span><p class="line862">If the <tt>IP:port</tt> is not in the tracker for the given shortid, no action is necessary.  If it is in the tracker, it is immediately dropped to avoid sending a bad peer to other clients (especially to <em>the same client</em>).  In the background, a request will be made to the peer to see whether it has the file and should be added back to the tracker. <span class="anchor" id="line-312"></span><span class="anchor" id="line-313"></span><p class="line874">The client could additionally send what went wrong (connection refused, connection timed out, successful RPC but negative response, successful RPC but data hash mismatch).  The server could then avoid making a &quot;File Check&quot; RPC to the client in the event of a network error.  However this requires trusting the report as valid, so maybe it's a bad idea. <span class="anchor" id="line-314"></span><span class="anchor" id="line-315"></span><p class="line867">
<h3 id="Peer_Restart">Peer Restart</h3>
<span class="anchor" id="line-316"></span><span class="anchor" id="line-317"></span><p class="line874">This is an indication from a client that it is starting up right now.  This means that they have no shortids cached, and if they are listed in the tracker for any shortid they should be removed from it. <span class="anchor" id="line-318"></span><span class="anchor" id="line-319"></span><p class="line874">Client sends: <span class="anchor" id="line-320"></span><span class="anchor" id="line-321"></span><ol type="1"><li>Their port <span class="anchor" id="line-322"></span><ul><li>Again, combined with the IP of the client end for a full address <span class="anchor" id="line-323"></span><span class="anchor" id="line-324"></span></li></ul></li></ol><p class="line862">Server response is empty.  Note that the server responds immediately and queues this <tt>IP:port</tt> to be removed from all file trackers in the background. <span class="anchor" id="line-325"></span><span class="anchor" id="line-326"></span><p class="line867">
<h3 id="Block_Request">Block Request</h3>
<span class="anchor" id="line-327"></span><span class="anchor" id="line-328"></span><p class="line874">This is a request from a client for a single block of a file.  The server responds with the data from that block and a (possibly empty) set of peers believed to have a copy of the file.  This is needed to guarantee forward progress, as the client could have received a non-empty peer set just as those peers were dropping the file.  When a client runs out of peers to try, it uses this call to get at least some data plus a new peer set. <span class="anchor" id="line-329"></span><span class="anchor" id="line-330"></span><p class="line874">Client sends: <span class="anchor" id="line-331"></span><span class="anchor" id="line-332"></span><ol type="1"><li>The shortid they want one block of <span class="anchor" id="line-333"></span></li><li>A byte count and byte offset within the file <span class="anchor" id="line-334"></span><span class="anchor" id="line-335"></span></li></ol><p class="line874">Server responds with: <span class="anchor" id="line-336"></span><span class="anchor" id="line-337"></span><ol type="1"><li><p class="line862">The type of response, which is either <strong>No Such File</strong> or <strong>File Contents</strong> <span class="anchor" id="line-338"></span><ul><li><p class="line862">If the response is <strong>No Such File</strong> no other data is sent <span class="anchor" id="line-339"></span></li><li><p class="line862">If the response is <strong>File Contents</strong>, the server then sends: <span class="anchor" id="line-340"></span><ol type="1"><li>A block hash (currently using the fingerprinting algorithm used by other parts of Vesta) <span class="anchor" id="line-341"></span></li><li>A sequence of bytes (the data in the requested block) <span class="anchor" id="line-342"></span></li><li><p class="line862">A possibly empty sequence of peer addresses, each as IPv4 <tt>IP:port</tt> addresses <span class="anchor" id="line-343"></span><span class="anchor" id="line-344"></span></li></ol></li></ul></li></ol><p class="line862">Note that we could do away with the <strong>File Request</strong> call in favor of using just this one by changing its result to include the file information and block hashes, or have <strong>File Request</strong> only send information, block hashes, and a peer set.  From a bandwidth standpoint it is a little attractive to have the first client to request a file get the entire file in a single request, but it makes it more difficult for the client to prioritize its work based on incoming filesystem reads. <span class="anchor" id="line-345"></span><span class="anchor" id="line-346"></span><p class="line862">Should the server require that the requested byte range corresponds to one of its blocks in the hash list it sends out in response to <strong>File Request</strong> calls?  If so, the client could just send a block index.  If not, the bytes requested could be placed arbitrarily (which would prevent the server from checking their hash against its hash list before sending) and/or arbitrarily large (which could allow for a denial-of-service attack). <span class="anchor" id="line-347"></span><span class="anchor" id="line-348"></span><p class="line874">Should the client be added to the peer set for this file after we've sent it this block?  At that point it has at least one block which it could send to peers.  If we do that we should change the protocol for the peer-to-peer file request call to allow a peer to answer with &quot;I only have part of that file, and not the part you aksed for&quot; possibly along with &quot;but here's the contents of a block I do have&quot;. <span class="anchor" id="line-349"></span><span class="anchor" id="line-350"></span><p class="line867">
<h2 id="Caching_Agent">Caching Agent</h2>
<span class="anchor" id="line-351"></span><span class="anchor" id="line-352"></span><p class="line874">This protocol would be used to make requests of the peer file caching agents.  It's presented here as a single RPC protocol, though some calls would be used by peers and some by the tracker server. <span class="anchor" id="line-353"></span><span class="anchor" id="line-354"></span><p class="line867">
<h3 id="File_Request-1">File Request</h3>
<span class="anchor" id="line-355"></span><span class="anchor" id="line-356"></span><p class="line874">This is a request from a peer caching agent for one block of a file which they need.  (Presumably the central tracker told the peer that we have it.) <span class="anchor" id="line-357"></span><span class="anchor" id="line-358"></span><p class="line874">Client sends: <span class="anchor" id="line-359"></span><span class="anchor" id="line-360"></span><ol type="1"><li>The shortid they need. <span class="anchor" id="line-361"></span></li><li>File attributes from the server: <span class="anchor" id="line-362"></span><ul><li>Size in bytes <span class="anchor" id="line-363"></span></li><li>Modification time <span class="anchor" id="line-364"></span></li><li>Executable flag <span class="anchor" id="line-365"></span></li></ul></li><li>A byte count and byte offset within the file <span class="anchor" id="line-366"></span></li><li>A hash for the block being requested <span class="anchor" id="line-367"></span><span class="anchor" id="line-368"></span></li></ol><p class="line874">Server responds with one of: <span class="anchor" id="line-369"></span><span class="anchor" id="line-370"></span><ol type="1"><li><p class="line862">The type of response, which is one of: <strong>No Copy Here</strong>, <strong>File Contents</strong>, or <strong>Attribute Mismatch</strong> <span class="anchor" id="line-371"></span><ul><li><p class="line862">If the response is <strong>No Copy Here</strong> no other data is sent <span class="anchor" id="line-372"></span></li><li><p class="line862">If the response is <strong>Attribute Mismatch</strong> no other data is sent <span class="anchor" id="line-373"></span></li><li><p class="line862">If the response is <strong>File Contents</strong>, the server then sends a sequence of bytes (the data in the requested byte range) <span class="anchor" id="line-374"></span><span class="anchor" id="line-375"></span></li></ul></li></ol><p class="line862">If the response is <strong>No Copy Here</strong>, the client should report this to the tracker with a &quot;Bad Peer Report&quot; RPC. <span class="anchor" id="line-376"></span><span class="anchor" id="line-377"></span><p class="line862">If the response is <strong>Attribute Mismatch</strong>, the client should report this to the tracker with a &quot;Bad Peer Report&quot; RPC and the peer should re-validate its copy against the the tracker with a &quot;Have File&quot; RPC. <span class="anchor" id="line-378"></span><span class="anchor" id="line-379"></span><p class="line874">Allowing retrieval of one block supports two things: <span class="anchor" id="line-380"></span><span class="anchor" id="line-381"></span><ul><li><p class="line862">Reading from multiple peers in parallel to tolerate peers listed in the tracker that fail to respond (see <a href="PeerToPeerDesign.html#flaky_peers">Tolerating Flaky Peers</a> above) and to distribute the request load across multiple peers. <span class="anchor" id="line-382"></span></li><li>Servicing a filesystem read from an NFS client without caching a local copy. <span class="anchor" id="line-383"></span><span class="anchor" id="line-384"></span></li></ul><p class="line874">Note that if the client retrieves the entire file and caches a local copy of it, they should report this to the tracker with a &quot;Have File&quot; RPC. <span class="anchor" id="line-385"></span><span class="anchor" id="line-386"></span><p class="line867"><em>We should change this call to have the server send back the file attributes and the block hash, having the caller do the attribute validation (which would put less trust in the peer).</em> <span class="anchor" id="line-387"></span><span class="anchor" id="line-388"></span><p class="line867">
<h3 id="File_Check">File Check</h3>
<span class="anchor" id="line-389"></span><span class="anchor" id="line-390"></span><p class="line874">This is a request from the central tracker to check whether this client has a valid copy of a file or not.  This would be initiated by a &quot;Bad Peer Report&quot; RPC from another peer. <span class="anchor" id="line-391"></span><span class="anchor" id="line-392"></span><p class="line874">Client (actually the tracker) sends: <span class="anchor" id="line-393"></span><span class="anchor" id="line-394"></span><ol type="1"><li>The shortid in question. <span class="anchor" id="line-395"></span></li><li>File attributes: <span class="anchor" id="line-396"></span><ul><li>Size in bytes <span class="anchor" id="line-397"></span></li><li>Modification time <span class="anchor" id="line-398"></span></li><li>Executable flag <span class="anchor" id="line-399"></span></li></ul></li><li>A data block size <span class="anchor" id="line-400"></span></li><li>A sequence of block hashes <span class="anchor" id="line-401"></span><span class="anchor" id="line-402"></span></li></ol><p class="line874">Server responds with either success (indicating that it does have the file and the attributes and clock hashes match) or failure (indicating that either it does not have the file cached or a mismatch on file attributes or block hashes). <span class="anchor" id="line-403"></span><span class="anchor" id="line-404"></span><p class="line874">In the event of a file attribute mismatch, a well-behaved server is obliged to drop the cached copy of the file (as it's incorrect). <span class="anchor" id="line-405"></span><span class="anchor" id="line-406"></span><p class="line874">A well-behaved server should re-compute the block hashes from it's on-disk copy of the file to protect against it becoming corrupted behind its back. <span class="anchor" id="line-407"></span><span class="anchor" id="line-408"></span><p class="line867"><em>We should change this call to have the server send back the file attributes and the block hashes, having the caller do the attribute validation (which would put less trust in the peer).</em> <span class="anchor" id="line-409"></span><span class="anchor" id="line-410"></span><p class="line867">
<h3 id="Weeding-1">Weeding</h3>
<span class="anchor" id="line-411"></span><span class="anchor" id="line-412"></span><p class="line874">This is an indication from the tracker that weeding is taking place and that files not being kept should be dropped from the local cache. <span class="anchor" id="line-413"></span><span class="anchor" id="line-414"></span><p class="line874">Client (the tracker) sends: <span class="anchor" id="line-415"></span><span class="anchor" id="line-416"></span><ol type="1"><li>A list of shortids to be kept (the &quot;keep list&quot;) <span class="anchor" id="line-417"></span></li><li>A timestamp (the &quot;keep time&quot;) <span class="anchor" id="line-418"></span><span class="anchor" id="line-419"></span></li></ol><p class="line874">Any files not in the keep list and with a modification time before the keep time should be dropped from the local cache. <span class="anchor" id="line-420"></span><span class="anchor" id="bottom"></span></div>
<div id="pagebottom"></div>
</div>


<div id="footer">
<ul id="credits">
<li><a href="http://moinmo.in/" title="This site uses the MoinMoin Wiki software.">MoinMoin Powered</a></li><li><a href="http://moinmo.in/Python" title="MoinMoin is written in Python.">Python Powered</a></li><li><a href="http://moinmo.in/GPL" title="MoinMoin is GPL licensed.">GPL licensed</a></li><li><a href="http://validator.w3.org/check?uri=referer" title="Click here to validate this page.">Valid HTML 4.01</a></li>
</ul>


</div>
</body>
</html>

