<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="robots" content="index,nofollow">

<title>ScalingUp/PeerToPeerDesign/PeerSelection - Vesta Wiki</title>
<script type="text/javascript" src="moin_static199/common/js/common.js"></script>

<script type="text/javascript">
<!--
var search_hint = "Search";
//-->
</script>


<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="../../moin_static199/vesta/css/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="../../moin_static199/vesta/css/screen.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="print" href="../../moin_static199/vesta/css/print.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="projection" href="../../moin_static199/vesta/css/projection.css">

<!-- css only for MS IE6/IE7 browsers -->
<!--[if lt IE 8]>
   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="../../moin_static199/vesta/css/msie.css">
<![endif]-->


<link rel="alternate" title="Vesta Wiki: ScalingUp/PeerToPeerDesign/PeerSelection" href="PeerSelection%3Fdiffs=1&amp;show_att=1&amp;action=rss_rc&amp;unique=0&amp;page=ScalingUp%252FPeerToPeerDesign%252FPeerSelection&amp;ddiffs=1.html" type="application/rss+xml">


<link rel="Start" href="FrontPage.html">
<link rel="Alternate" title="Wiki Markup" href="PeerSelection%3Faction=raw.html">
<link rel="Alternate" media="print" title="Print View" href="PeerSelection%3Faction=print.html">
<link rel="Up" href="../PeerToPeerDesign.html">
<link rel="Appendix" title="autogenerated-52862e2ce8b36355a12053fbae8277525a5f042d.png" href="PeerSelection%3Faction=AttachFile&amp;do=view&amp;target=autogenerated-52862e2ce8b36355a12053fbae8277525a5f042d.png.html">
<link rel="Appendix" title="autogenerated-5f002c98c935dc9706ae70310308662f041c54f3.png" href="PeerSelection%3Faction=AttachFile&amp;do=view&amp;target=autogenerated-5f002c98c935dc9706ae70310308662f041c54f3.png.html">
<link rel="Appendix" title="autogenerated-7249e8dd6499139bf098b8ce24006b81cfb30a88.png" href="PeerSelection%3Faction=AttachFile&amp;do=view&amp;target=autogenerated-7249e8dd6499139bf098b8ce24006b81cfb30a88.png.html">
<link rel="Appendix" title="autogenerated-9cbb8bcccf81cc5136b4508fbe0ddff298ba2537.png" href="PeerSelection%3Faction=AttachFile&amp;do=view&amp;target=autogenerated-9cbb8bcccf81cc5136b4508fbe0ddff298ba2537.png.html">
<link rel="Appendix" title="autogenerated-a33ed4db863374cdb7f792c656a94788cfde794e.png" href="PeerSelection%3Faction=AttachFile&amp;do=view&amp;target=autogenerated-a33ed4db863374cdb7f792c656a94788cfde794e.png.html">
<link rel="Appendix" title="autogenerated-ab1797b53470e8c79654875fb34209f69e6abaa1.png" href="PeerSelection%3Faction=AttachFile&amp;do=view&amp;target=autogenerated-ab1797b53470e8c79654875fb34209f69e6abaa1.png.html">
<link rel="Appendix" title="autogenerated-d3d753633ee884998041ffa5c5e52eba00539b89.png" href="PeerSelection%3Faction=AttachFile&amp;do=view&amp;target=autogenerated-d3d753633ee884998041ffa5c5e52eba00539b89.png.html">
<link rel="Appendix" title="autogenerated-ed8986670aed9e761da39383aac413b9ce290d45.png" href="PeerSelection%3Faction=AttachFile&amp;do=view&amp;target=autogenerated-ed8986670aed9e761da39383aac413b9ce290d45.png.html">
<link rel="Appendix" title="delete.me.to.regenerate.images" href="PeerSelection%3Faction=AttachFile&amp;do=view&amp;target=delete.me.to.regenerate.images.html">
<link rel="Search" href="FindPage.html">
<link rel="Index" href="TitleIndex.html">
<link rel="Glossary" href="WordIndex.html">
<link rel="Help" href="HelpOnFormatting.html">
</head>

<body  lang="en" dir="ltr">

<div id="header">

<form id="searchform" method="get" action="PeerSelection.html">
<div>
<input type="hidden" name="action" value="fullsearch">
<input type="hidden" name="context" value="180">
<label for="searchinput">Search:</label>
<input id="searchinput" type="text" name="value" value="" size="20"
    onfocus="searchFocus(this)" onblur="searchBlur(this)"
    onkeyup="searchChange(this)" onchange="searchChange(this)" alt="Search">
<input id="titlesearch" name="titlesearch" type="submit"
    value="Titles" alt="Search Titles">
<input id="fullsearch" name="fullsearch" type="submit"
    value="Text" alt="Search Full Text">
</div>
</form>
<script type="text/javascript">
<!--// Initialize search form
var f = document.getElementById('searchform');
f.getElementsByTagName('label')[0].style.display = 'none';
var e = document.getElementById('searchinput');
searchChange(e);
searchBlur(e);
//-->
</script>

<div id="logo"><a href="FrontPage.html"><img src="wiki/vesta/img/1line.png" alt="Vesta" height=44 width=202></a></div>
<div id="locationline">

<ul id="pagelocation">
<li><a href="ScalingUp.html">ScalingUp</a></li><li><a href="../PeerToPeerDesign.html">PeerToPeerDesign</a></li><li><a href="PeerSelection.html">PeerSelection</a></li>
</ul>

</div>
</div>

<div id="sidebar">
<div class="sidepanel">
<h1>Wiki</h1>

<ul id="navibar">
<li class="wikilink"><a href="RecentChanges.html">RecentChanges</a></li><li class="wikilink"><a href="FindPage.html">FindPage</a></li><li class="wikilink"><a href="HelpContents.html">HelpContents</a></li><li class="current"><a href="PeerSelection.html">PeerSelection</a></li>
</ul>

</div>
<div class="sidepanel">
<h1>User</h1>
<ul id="username"><li><a href="PeerSelection%3Faction=login.html" id="login" rel="nofollow">Login</a></li></ul>
</div>
</div>

<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><span class="anchor" id="line-5"></span><p class="line867"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li>
<a href="PeerSelection.html#Introduction">Introduction</a></li><li>
<a href="PeerSelection.html#Previous_Approaches">Previous Approaches</a><ol><li>
<a href="PeerSelection.html#Random">Random</a></li><li>
<a href="PeerSelection.html#IP_Difference">IP Difference</a></li></ol></li><li>
<a href="PeerSelection.html#Considerations">Considerations</a><ol><li>
<a href="PeerSelection.html#Latency">Latency</a></li><li>
<a href="PeerSelection.html#Bandwidth_.2F_Capacity">Bandwidth / Capacity</a></li><li>
<a href="PeerSelection.html#Locality">Locality</a></li><li>
<a href="PeerSelection.html#Fairness">Fairness</a></li></ol></li><li>
<a href="PeerSelection.html#Planned_New_Approach">Planned New Approach</a><ol><li>
<a href="PeerSelection.html#Comparison_Methods">Comparison Methods</a><ol><li>
<a href="PeerSelection.html#Method_1:_Peer-Specific_Recent_Pseudo-Average_Latency">Method 1: Peer-Specific Recent Pseudo-Average Latency</a></li><li>
<a href="PeerSelection.html#Method_2:_Peer-Specific_Overall_Average_Latency">Method 2: Peer-Specific Overall Average Latency</a></li><li>
<a href="PeerSelection.html#Method_3:_Network_Neighborhood_Overall_Average_Latency">Method 3: Network Neighborhood Overall Average Latency</a></li><li>
<a href="PeerSelection.html#Method_4:_Local_Network_or_not">Method 4: Local Network or not</a></li><li>
<a href="PeerSelection.html#Method_5:_Number_of_Matching_Leading_IP_Bits">Method 5: Number of Matching Leading IP Bits</a></li></ol></li><li>
<a href="PeerSelection.html#Other_Selection_Details">Other Selection Details</a><ol><li>
<a href="PeerSelection.html#Comparing_Peers_on_Local_Network">Comparing Peers on Local Network</a></li><li>
<a href="PeerSelection.html#Randomize_Amongst_Peer_Networks">Randomize Amongst Peer Networks</a></li><li>
<a href="PeerSelection.html#Sorting_Peers">Sorting Peers</a></li><li>
<a href="PeerSelection.html#What_if_the_Server_is_Faster.3F">What if the Server is Faster?</a></li></ol></li><li>
<a href="PeerSelection.html#Simple_Example">Simple Example</a></li><li>
<a href="PeerSelection.html#Detailed_Example">Detailed Example</a></li><li>
<a href="PeerSelection.html#Implementation_Notes">Implementation Notes</a></li></ol></li></ol></div> <span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span><p class="line867">
<h1 id="Introduction">Introduction</h1>
<span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line874">The method of selecting which peer(s) to get a file from affects how quickly file contents can be delivered to processes interested in reading those files. <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line862">If you're not already familiar with the design, it may help to start by reading (or at least skimming) <a href="../PeerToPeerDesign.html">the description of the peer to peer design</a>. <span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span><p class="line867">
<h1 id="Previous_Approaches">Previous Approaches</h1>
<span class="anchor" id="line-14"></span><span class="anchor" id="line-15"></span><p class="line874">The peer selection algorithm has evolved with the prototype through two different methods. <span class="anchor" id="line-16"></span><span class="anchor" id="line-17"></span><p class="line867">
<h2 id="Random">Random</h2>
<span class="anchor" id="line-18"></span><span class="anchor" id="line-19"></span><p class="line874">The first peer selection method was totally random.  When the tracker server provides a list of peers with a copy of the file, peers were picked at random from that list. <span class="anchor" id="line-20"></span><span class="anchor" id="line-21"></span><p class="line874">The concept behind this was that by spreading out the work evenly among all the peers, it would avoid directing too many requests to particular peers. <span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><p class="line874">The obvious flaw is that this made no attempt to select a peer based on latency, bandwidth, or network locality. <span class="anchor" id="line-24"></span><span class="anchor" id="line-25"></span><p class="line867">
<h2 id="IP_Difference">IP Difference</h2>
<span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span><p class="line874">The second peer selection method was to subtract each peer's IP address to the local machine's IP address and treat the absolute value of the difference like a distance.  The available peers would be sorted by the IP difference, and the peers would be tried starting with the ones with the lowest difference. <span class="anchor" id="line-28"></span><span class="anchor" id="line-29"></span><p class="line862">For example, suppose the local machine's IP address was <tt>192.168.1.10</tt> and the available peers were <tt>192.168.1.5</tt> through <tt>192.168.1.15</tt>.  They would be tried in the following order: <span class="anchor" id="line-30"></span><span class="anchor" id="line-31"></span><p class="line867"><span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span><span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><span class="anchor" id="line-42"></span><pre><span class="anchor" id="line-1"></span>192.168.1.9
<span class="anchor" id="line-2"></span>192.168.1.11
<span class="anchor" id="line-3"></span>192.168.1.8
<span class="anchor" id="line-4"></span>192.168.1.12
<span class="anchor" id="line-5"></span>192.168.1.7
<span class="anchor" id="line-6"></span>192.168.1.13
<span class="anchor" id="line-7"></span>192.168.1.6
<span class="anchor" id="line-8"></span>192.168.1.14
<span class="anchor" id="line-9"></span>192.168.1.5
<span class="anchor" id="line-10"></span>192.168.1.15</pre><span class="anchor" id="line-43"></span><span class="anchor" id="line-44"></span><p class="line874">This method has a much greater tendency than random selection to select peers which are closer on the network.  For example, in most cases machines on the same local subnet (i.e. matching the netmask of a local network interface, reachable without passing through a router) will have a lower IP difference than machines on a different subnet. <span class="anchor" id="line-45"></span><span class="anchor" id="line-46"></span><p class="line862">One case in which this method performs less than optimally is when there are two separate subnets which have adjacent IP ranges.  Suppose there are file caching agents on the two networks <tt>10.12.34.0/24</tt> and <tt>10.12.35.0/24</tt>.  An agent on a machine with the address <tt>10.12.35.10</tt> will consider <tt>10.12.34.250</tt> to be closer than <tt>10.12.35.100</tt>. <span class="anchor" id="line-47"></span><span class="anchor" id="line-48"></span><p class="line862">Another performance problem with this method is that machines in the middle of the IP range will receive more traffic than those at the ends of the IP range.  Suppose the file caching agents have addresses from <tt>192.168.1.1</tt> through <tt>192.168.1.99</tt>.  The agent with the addresses <tt>192.168.1.50</tt> will receive the most requests, because the 48 agents with higher addresses will try it before any with a lower address and the 48 agents with lower addresses will try it before any with a higher address.  A potentially even worse case is when multiple subnets are involved, connected by a router with limited bandwidth.  Suppose there are file caching agents in the three networks <tt>10.1.20.0/24</tt>, <tt>10.1.30.0/24</tt>, and <tt>10.1.40.0/24</tt>.  The agents in <tt>10.1.20.0/24</tt> will try agents in <tt>10.1.30.0/24</tt> before agents in <tt>10.1.40.0/24</tt>.  Similarly, the agents <tt>10.1.40.0/24</tt> will try agents in <tt>10.1.30.0/24</tt> before agents in <tt>10.1.40.0/24</tt>.  If the three networks are all connected to a router by links of the same capacity, the connection to <tt>10.1.30.0/24</tt> will get the most peer-to-peer traffic. <span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span><p class="line867">
<h1 id="Considerations">Considerations</h1>
<span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><p class="line874">There are multiple issues to consider in the design of a method for selecting peers. <span class="anchor" id="line-53"></span><span class="anchor" id="line-54"></span><p class="line867">
<h2 id="Latency">Latency</h2>
<span class="anchor" id="line-55"></span><span class="anchor" id="line-56"></span><p class="line874">When making a request to a peer, how long does it take for a response to arrive?  Ultimately, the goal is to deliver file contents to processes reading the files as quickly as possible.  The ideal algorithm would select peers with the lowest latency. <span class="anchor" id="line-57"></span><span class="anchor" id="line-58"></span><p class="line874">Network locality is obviously a factor in latency.  The more layers of network switching and routing a packet must pass through, the longer it will take to reach its destination. <span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span><p class="line874">Network capacity can also affect latency.  If a network link becomes saturated (by more packets trying to cross the link at one time than is possible), some packets will be delayed. <span class="anchor" id="line-61"></span><span class="anchor" id="line-62"></span><p class="line874">The latency of individual transactions can be measured fairly accurately.  However, latency can change due to temporary conditions both in the network and on the peer machine processing the request.  Neither overall average latency nor the latency of recent requests is necessarily a good predictor of latency of the next request. <span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span><p class="line867">
<h2 id="Bandwidth_.2F_Capacity">Bandwidth / Capacity</h2>
<span class="anchor" id="line-65"></span><span class="anchor" id="line-66"></span><p class="line874">Networks never have uniform capacity for the transmission of data between all hosts.  Between any pair of hosts, the maximum capacity is limited by the minimum capacity of any link which must be traversed.  However the available capacity between any pair of hosts is also limited by the amount of traffic between other hosts which traverse the same links. <span class="anchor" id="line-67"></span><span class="anchor" id="line-68"></span><p class="line874">Unfortunately, network capacity is very difficult for a program to measure directly.  An estimate of capacity could be computed by dividing the quantity of data transmitted by the time taken to receive a response for each request for data.  However its not clear that such an estimate would ever be a better basis for choosing a peer than latency alone. <span class="anchor" id="line-69"></span><span class="anchor" id="line-70"></span><p class="line862">Relevant to this discussion, <a href="../../ScottVenier.html">ScottVenier</a> pointed out the now classic essay <a class="http" href="http://www.stuartcheshire.org/rants/Latency.html">It's the Latency, Stupid</a>.  <a href="../../KenSchalk.html">KenSchalk</a> also found the more recent <a class="http" href="http://www.edgeblog.net/2007/its-still-the-latency-stupid/">Its Still the Latency, Stupid</a>. <span class="anchor" id="line-71"></span><span class="anchor" id="line-72"></span><p class="line867">
<h2 id="Locality">Locality</h2>
<span class="anchor" id="line-73"></span><span class="anchor" id="line-74"></span><p class="line874">Networks can usually be viewed as a tree of switches and routers.  (The reality is occasionally a little more complicated.)  Requests from one host to another go up through the tree of switches/routers and then back down on another path.  Almost universally latency is lower and capacity is higher the fewer layers of this tree a request must pass through. <span class="anchor" id="line-75"></span><span class="anchor" id="line-76"></span><p class="line874">Network locality is also difficult for a program to measure.  The easiest determination to make is whether a request to a particular peer will pass through a router or not.  This can be determined based on the local address and netmask for each network interface.  It is also possible to determine how many routers a request must pass through, though that is significantly more difficult. <span class="anchor" id="line-77"></span><span class="anchor" id="line-78"></span><p class="line874">Compared to routers, switches are largely invisible to programs.  However, depending on the number of layers of network switches between individual machines and the first router, they can be significant for performance. <span class="anchor" id="line-79"></span><span class="anchor" id="line-80"></span><p class="line867">
<h2 id="Fairness">Fairness</h2>
<span class="anchor" id="line-81"></span><span class="anchor" id="line-82"></span><p class="line874">Distributing work evenly throughout a network of peers generally improves overall performance.  Directing more requests to some peers and less to other will generally degrade overall performance.  <span class="anchor" id="line-83"></span><span class="anchor" id="line-84"></span><p class="line874">However it's important not to ignore other factors when trying to distribute work fairly.  (See comments above about random peer selection.)  It does make sense to distribute requests fairly among peers with similar locality / latency. <span class="anchor" id="line-85"></span><span class="anchor" id="line-86"></span><p class="line867">
<h1 id="Planned_New_Approach">Planned New Approach</h1>
<span class="anchor" id="line-87"></span><span class="anchor" id="line-88"></span><p class="line874">How will a new peer selection algorithm work?  (This essentially describes a work-in-progress design.) <span class="anchor" id="line-89"></span><span class="anchor" id="line-90"></span><p class="line867">
<h2 id="Comparison_Methods">Comparison Methods</h2>
<span class="anchor" id="line-91"></span><span class="anchor" id="line-92"></span><p class="line874">The choice between peers will be evaluated by a series of different methods.  If the information for some methods is not be available (e.g. we have no records of latency because we haven't previously communicated with the peer), then the selection process will move on to other methods.  Generally, this moves from a more dynamic assessment based on current conditions to a more static assessment based on long-term conditions or unchanging inputs. <span class="anchor" id="line-93"></span><span class="anchor" id="line-94"></span><p class="line867">
<h3 id="Method_1:_Peer-Specific_Recent_Pseudo-Average_Latency">Method 1: Peer-Specific Recent Pseudo-Average Latency</h3>
<span class="anchor" id="line-95"></span><span class="anchor" id="line-96"></span><p class="line874">The latency of each request to a peer will be measured (i.e. the complete round-trip time from sending the request to receiving the full response).  Peers will be compared based on a pseudo-average latency over &quot;recent&quot; requests.  This will allow the selection process to avoid temporary problems like network congestion or competing jobs on a peer slowing its responses. <span class="anchor" id="line-97"></span><span class="anchor" id="line-98"></span><p class="line874">Rather than using a true average of recent requests, we'll keep a pseudo-average.  When a new request to the peer completes, we'll take the average of the current pseudo-average and the new response time, making that the new pseudo-average.  This produces an estimate that is biased towards the last response time, but doesn't completely ignore previous responses.  The main advantage of this is that it avoids keeping a queue of records of recent response times, adding new items to the queue, removing old items from the queue, and averaging across the queue.  The data structure is simple, and the computation work is small. <span class="anchor" id="line-99"></span><span class="anchor" id="line-100"></span><p class="line874">We could adjust the bias by changing the formula from this: <span class="anchor" id="line-101"></span><span class="anchor" id="line-102"></span><p class="line867"><span class="anchor" id="line-103"></span><span class="anchor" id="line-104"></span><pre><span class="anchor" id="line-1-1"></span>new_pseudo_average = (pseudo_average + new_time) / 2</pre><span class="anchor" id="line-105"></span><span class="anchor" id="line-106"></span><p class="line874">To a form that gives greater weight to previous responses: <span class="anchor" id="line-107"></span><span class="anchor" id="line-108"></span><p class="line867"><span class="anchor" id="line-109"></span><span class="anchor" id="line-110"></span><pre><span class="anchor" id="line-1-2"></span>new_pseudo_average = ((pseudo_average * past_weight) + new_time) / (past_weight + 1)</pre><span class="anchor" id="line-111"></span><span class="anchor" id="line-112"></span><p class="line862">It's unclear how to best choose the bias, so it will be configurable.  Possible defaults for <tt>past_weight</tt> would be 2 to 4. <span class="anchor" id="line-113"></span><span class="anchor" id="line-114"></span><p class="line862">(<a href="../../ScottVenier.html">ScottVenier</a> suggested this pseudo-average algorithm.) <span class="anchor" id="line-115"></span><span class="anchor" id="line-116"></span><p class="line874">To avoid treating temporary conditions in the past as indicative of future behavior, records of requests past some time horizon will not be considered &quot;recent.&quot;  It's unclear how to size this time window, so it will be configurable.  The default could be set at 1 minute. <span class="anchor" id="line-117"></span><span class="anchor" id="line-118"></span><p class="line874">When the last request recorded in the recent latency pseudo-average is too far in the past, the selection process will fall back on the next method of comparing peers.  When computing a new pseudo-average based on the latency of a new operation in this case, it will use the overall average latency in place of the pseudo-average to compute a new pseudo-average.  <span class="anchor" id="line-119"></span><span class="anchor" id="line-120"></span><p class="line867">
<h3 id="Method_2:_Peer-Specific_Overall_Average_Latency">Method 2: Peer-Specific Overall Average Latency</h3>
<span class="anchor" id="line-121"></span><span class="anchor" id="line-122"></span><p class="line874">An overall average latency for each peer will be kept.  This would not be sensitive to fluctuations in peer response time due to temporary conditions.  The recent pseudo-average should be a better predictor until it gets out of date.  The overall average should be a better predictor when we don't have any recent latency data. <span class="anchor" id="line-123"></span><span class="anchor" id="line-124"></span><p class="line867">
<h3 id="Method_3:_Network_Neighborhood_Overall_Average_Latency">Method 3: Network Neighborhood Overall Average Latency</h3>
<span class="anchor" id="line-125"></span><span class="anchor" id="line-126"></span><p class="line874">Peers will be grouped into &quot;network neighborhoods,&quot; and the average latency for each neighborhood will also be recorded.  If we don't have any latency data for a peer, we can use the average for its neighborhood instead.  In general, that should be a good predictor of latency. <span class="anchor" id="line-127"></span><span class="anchor" id="line-128"></span><p class="line874">One method of grouping peers would be to apply the local machine's netmask to each peers address.  This may not accurately represent network topology, but is a reasonable guess. <span class="anchor" id="line-129"></span><span class="anchor" id="line-130"></span><p class="line862">To allow for better representation of network topology, there will be a configuration variable where administrators can provide one or more <a class="http" href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">CIDR</a> specifications of network neighborhoods.  If a peer's address doesn't match any of those, we'll fall back on using our local netmask. <span class="anchor" id="line-131"></span><span class="anchor" id="line-132"></span><p class="line867">
<h3 id="Method_4:_Local_Network_or_not">Method 4: Local Network or not</h3>
<span class="anchor" id="line-133"></span><span class="anchor" id="line-134"></span><p class="line874">In the absence of any latency data to evaluate the relative cost of two different peers, we would check whether each is on a locally connected network.  In other words, we would see if it matches based on the address and netmask of the local machine.  (Take the bitwise AND of the netmask with the local IP address and the peer's IP address, and see whether the results match.)  A peer on the local network would be chosen before a peer on a non-local network. <span class="anchor" id="line-135"></span><span class="anchor" id="line-136"></span><p class="line867">
<h3 id="Method_5:_Number_of_Matching_Leading_IP_Bits">Method 5: Number of Matching Leading IP Bits</h3>
<span class="anchor" id="line-137"></span><span class="anchor" id="line-138"></span><p class="line874">For peers that are not on the local network and for which no relevant latency data is available, their relative cost will be evaluated based on the number of leading bits of the IP address which matches the local host.  The more leading IP bits match, the closer a peer is (and therefore the faster it is likely to respond).  The fewer leading IP bits match, the further away a peer is (and therefore the slower it is likely to respond).  (Obviously any machine on the local network matches at least as many bits as the netmask.) <span class="anchor" id="line-139"></span><span class="anchor" id="line-140"></span><p class="line874">To avoid artificially ordering peers that are really equidistant, not every bit will be considered significant.  For example, consider the following peer subnets all connected to the same router: <span class="anchor" id="line-141"></span><span class="anchor" id="line-142"></span><p class="line867"><span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><span class="anchor" id="line-145"></span><span class="anchor" id="line-146"></span><span class="anchor" id="line-147"></span><span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><pre><span class="anchor" id="line-1-3"></span>10.123.45.0/24
<span class="anchor" id="line-2-1"></span>10.123.46.0/24
<span class="anchor" id="line-3-1"></span>10.123.47.0/24
<span class="anchor" id="line-4-1"></span>10.123.48.0/24
<span class="anchor" id="line-5-1"></span>10.123.49.0/24
<span class="anchor" id="line-6-1"></span>10.123.50.0/24</pre><span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><p class="line874">If all of these subnets are considered together, they have only 19 leading bits in common.  However some of them have 20 leading bits in common with each other.  If this is considered significant, then the first three subnets would treat each other as &quot;closer&quot; than the last three subnets and vice versa.  That kind of artificial clustering would lead to an unfair distribution of requests between peers and could cause network bottlenecks. <span class="anchor" id="line-152"></span><span class="anchor" id="line-153"></span><p class="line862">It's impossible to know how different numbers of leading bits map to real-world network topology.  In a large corporate Intranet using the class A private range (<tt>10.0.0.0/8</tt>), it could be that 16 leading bits of the IP will always match for machines in the same building and 24 leading bits of the IP forms the local subnet.  Or for smaller networks it could be that 24 bits match for machines in the same building and the local netmask of each machine has 28 leading bits set. <span class="anchor" id="line-154"></span><span class="anchor" id="line-155"></span><p class="line874">Since different users may have different network architectures, the IP matching &quot;distance&quot; categories should be configurable as a list of numbers of matching leading bits.  The default could be to only consider matches of 8, 16, or 24 leading bits.  An administrator could change this with the configuration setting to 16, 20, 24, and 28 leading bits. <span class="anchor" id="line-156"></span><span class="anchor" id="line-157"></span><p class="line867">
<h2 id="Other_Selection_Details">Other Selection Details</h2>
<span class="anchor" id="line-158"></span><span class="anchor" id="line-159"></span><p class="line867">
<h3 id="Comparing_Peers_on_Local_Network">Comparing Peers on Local Network</h3>
<span class="anchor" id="line-160"></span><span class="anchor" id="line-161"></span><p class="line874">Suppose there are several peers available, all on the local network, and no latency data is available for those peers.  They would be considered equi-distant, so how should a choice be made between them? <span class="anchor" id="line-162"></span><span class="anchor" id="line-163"></span><p class="line874">Random selection is one option.  Sorting them by IP address would be another.  It's not clear whether either would have any benefit. <span class="anchor" id="line-164"></span><span class="anchor" id="line-165"></span><p class="line874">It probably doesn't matter very much, as once an agent begins communicating with peers it will quickly acquire latency data which will allow future selection to be more precise. <span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span><p class="line867">
<h3 id="Randomize_Amongst_Peer_Networks">Randomize Amongst Peer Networks</h3>
<span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><p class="line874">For the case of multiple peers on non-local networks for which no latency data is available, it seems wisest to choose randomly.  The network topology and capacity between the local machine and such peers may be asymmetric.  Choosing randomly should make it less likely to accidentally prefer a set of peers that will all respond slowly.  Also, it ensures fairness among the peer networks. <span class="anchor" id="line-170"></span><span class="anchor" id="line-171"></span><p class="line867">
<h3 id="Sorting_Peers">Sorting Peers</h3>
<span class="anchor" id="line-172"></span><span class="anchor" id="line-173"></span><p class="line862">By using the different comparison methods outlined above, a list of peers could be sorted.  That would provide a <em>total order</em>, allowing the selection of peers to simply take elements from the beginning of the list. <span class="anchor" id="line-174"></span><span class="anchor" id="line-175"></span><p class="line862">However in some cases the comparison methods will not provide any relative ordering between some peers.  They would essentially be considered equi-distant from the local machine, or to have an equal estimated latency or cost.  As described in the previous sub-section, it's probably best to pick randomly amongst peers with an identical estimated cost.  To allow that kind of random picking among peers of equal cost, we need a <em>partial order</em> rather than a total order. <span class="anchor" id="line-176"></span><span class="anchor" id="line-177"></span><p class="line874">The data structure into which available peers are &quot;sorted&quot; should therefore be a list of lists.  Each element of the outer list will be a list of peers considered to have an equal cost. <span class="anchor" id="line-178"></span><span class="anchor" id="line-179"></span><p class="line862">In some cases, it may be difficult to place peers into these different cost &quot;buckets.&quot;  Suppose we have four peers, <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, and <strong>D</strong>.  None are on the local network.  All have the same number of matching leading IP bits, so would be considered to have an equal cost by that measure.  However, latency data is available for <strong>A</strong> and <strong>C</strong>.  <strong>A</strong> has lower latency than <strong>C</strong>, so would have a lower cost.  Should <strong>B</strong> and <strong>D</strong> be grouped with <strong>A</strong> or with <strong>C</strong>?  Or should <strong>B</strong> and <strong>D</strong> be grouped after <strong>C</strong> or before <strong>A</strong>? <span class="anchor" id="line-180"></span><span class="anchor" id="line-181"></span><ul><li><p class="line862">If we group <strong>B</strong> and <strong>D</strong> with <strong>C</strong>, <strong>A</strong> will be preferred over either <strong>B</strong> and <strong>D</strong>.  That doesn't seem like the best choice, as <strong>B</strong> and/or <strong>D</strong> could turn out to have a lower actual latency than <strong>A</strong>. <span class="anchor" id="line-182"></span></li><li><p class="line862">Similarly, it doesn't seem wise to group <strong>B</strong> and <strong>D</strong> after <strong>C</strong> (and thus also after <strong>A</strong>), as that would make it even less likely that they would ever be contacted. <span class="anchor" id="line-183"></span></li><li><p class="line862">Grouping <strong>B</strong> and <strong>D</strong> after <strong>A</strong> would still prefer <strong>A</strong> over <strong>B</strong> and <strong>D</strong>.  That could be bad if <strong>B</strong> and <strong>D</strong> have lower latency than <strong>A</strong> (or even equivalent latency to <strong>A</strong>). <span class="anchor" id="line-184"></span></li><li><p class="line862">Grouping <strong>B</strong> and <strong>D</strong> before <strong>A</strong> would preferentially choose peers we have never contacted before.  That could be bad if <strong>B</strong> and <strong>D</strong> have higher latency than <strong>A</strong>, but after communicating with them once we would have latency data that would select <strong>A</strong> next time. <span class="anchor" id="line-185"></span></li><li><p class="line862">Grouping <strong>B</strong> and <strong>D</strong> with <strong>A</strong> (and selecting from them randomly) would avoid preferring peers we have never contacted before over peers which have had low latency in the past.  However it would make it likely that we would select a host we haven't communicated with before and thus build up latency data bout it. <span class="anchor" id="line-186"></span><span class="anchor" id="line-187"></span></li></ul><p class="line862">Probably the final option (grouping <strong>B</strong> and <strong>D</strong> with <strong>A</strong>) will be used. <span class="anchor" id="line-188"></span><span class="anchor" id="line-189"></span><p class="line867">
<h3 id="What_if_the_Server_is_Faster.3F">What if the Server is Faster?</h3>
<span class="anchor" id="line-190"></span><span class="anchor" id="line-191"></span><p class="line874">There may be some peers which exhibit higher latency than the tracker (server).  That could be caused by network asymmetries, network congestion, or just peers that are very far away. <span class="anchor" id="line-192"></span><span class="anchor" id="line-193"></span><p class="line874">When trying to select a peer, if there is reason to believe that none of the available peers will respond faster than the tracker it makes sense to go to the tracker rather than a peer.  This is already supported by the network protocol for cases where peers can't be reached or don't have the file in question.  (The latter can happen due to a race between the tracker sending a list of peers, and the peers on that list deciding to drop the file to reclaim disk space.)  As a side benefit, the agent will get an updated list of peers, some of which may turn out to be faster. <span class="anchor" id="line-194"></span><span class="anchor" id="line-195"></span><p class="line874">To support this determination, we will need to keep an all-time latency average for the tracker as well as a recent latency pseudo-average.  To be sure we compare them fairly, these latencies for the server will only be recorded for the analogous single-block request, not for other kinds of requests which may have different latency characteristics. <span class="anchor" id="line-196"></span><span class="anchor" id="line-197"></span><p class="line867">
<h2 id="Simple_Example">Simple Example</h2>
<span class="anchor" id="line-198"></span><span class="anchor" id="line-199"></span><p class="line862">For the sake of this discussion, imagine there are just two peers available, which we'll call <strong>PeerA</strong> and <strong>PeerB</strong>. <span class="anchor" id="line-200"></span><span class="anchor" id="line-201"></span><p class="line874">First, a latency value for each peer would be selected.  In order we would check for: <span class="anchor" id="line-202"></span><span class="anchor" id="line-203"></span><ol type="1"><li>Peer-specific recent pseudo-average latency that was last updated within the specified time window. <span class="anchor" id="line-204"></span></li><li>Peer-specific overall average latency. <span class="anchor" id="line-205"></span></li><li>Network neighborhood overall average latency. <span class="anchor" id="line-206"></span><span class="anchor" id="line-207"></span></li></ol><p class="line862">It doesn't matter which kind of latency we select for each peer, as the values will all have the same units.  If the latency value for <strong>PeerA</strong> is lower than the latency value for <strong>PeerB</strong>, <strong>PeerA</strong> would be preferred. <span class="anchor" id="line-208"></span><span class="anchor" id="line-209"></span><p class="line862">If we cannot determine a latency value for either peer, we would then check whether each peer is on a local network.  If <strong>PeerA</strong> can be reached without going through a router and <strong>PeerB</strong> cannot, <strong>PeerA</strong> would be preferred. <span class="anchor" id="line-210"></span><span class="anchor" id="line-211"></span><p class="line862">If neither peer is on a local network, their distance will be estimated based on the number of leading bits in their IP addresses which match the local host's IP address.  If <strong>PeerA</strong> has 16 leading IP address bits matching the local host and <strong>PeerB</strong> has only 8 leading IP address bits matching the local host, <strong>PeerA</strong> would be preferred. <span class="anchor" id="line-212"></span><span class="anchor" id="line-213"></span><p class="line867">
<h2 id="Detailed_Example">Detailed Example</h2>
<span class="anchor" id="line-214"></span><span class="anchor" id="line-215"></span><p class="line862">For this example, we'll consider the decisions of a caching agent running on a host with the IP address <tt>10.12.34.56</tt> and the netmask <tt>255.255.255.0</tt> (i.e. it's local network is <tt>10.12.34.0/24</tt>). <span class="anchor" id="line-216"></span><span class="anchor" id="line-217"></span><p class="line862">Suppose that the tracker has given it a set of twelve peers that have a copy of the file that it's interested.  We'll call thhose peers <strong>PeerA</strong>, <strong>PeerB</strong>, and so on through <strong>PeerL</strong>.  Those peers have the following IP addresses: <span class="anchor" id="line-218"></span><span class="anchor" id="line-219"></span><div><table><tbody><tr>  <td><p class="line891"><strong>PeerA</strong></td>
  <td><p class="line862">10.12.34.45</td>
</tr>
<tr>  <td><span class="anchor" id="line-220"></span><p class="line891"><strong>PeerB</strong></td>
  <td><p class="line862">10.12.34.67</td>
</tr>
<tr>  <td><span class="anchor" id="line-221"></span><p class="line891"><strong>PeerC</strong></td>
  <td><p class="line862">10.12.34.78</td>
</tr>
<tr>  <td><span class="anchor" id="line-222"></span><p class="line891"><strong>PeerD</strong></td>
  <td><p class="line862">10.12.23.45</td>
</tr>
<tr>  <td><span class="anchor" id="line-223"></span><p class="line891"><strong>PeerE</strong></td>
  <td><p class="line862">10.12.23.56</td>
</tr>
<tr>  <td><span class="anchor" id="line-224"></span><p class="line891"><strong>PeerF</strong></td>
  <td><p class="line862">10.12.45.67</td>
</tr>
<tr>  <td><span class="anchor" id="line-225"></span><p class="line891"><strong>PeerG</strong></td>
  <td><p class="line862">10.12.45.78</td>
</tr>
<tr>  <td><span class="anchor" id="line-226"></span><p class="line891"><strong>PeerH</strong></td>
  <td><p class="line862">10.12.56.78</td>
</tr>
<tr>  <td><span class="anchor" id="line-227"></span><p class="line891"><strong>PeerI</strong></td>
  <td><p class="line862">10.12.56.89</td>
</tr>
<tr>  <td><span class="anchor" id="line-228"></span><p class="line891"><strong>PeerJ</strong></td>
  <td><p class="line862">10.11.23.45</td>
</tr>
<tr>  <td><span class="anchor" id="line-229"></span><p class="line891"><strong>PeerK</strong></td>
  <td><p class="line862">10.11.23.45</td>
</tr>
<tr>  <td><span class="anchor" id="line-230"></span><p class="line891"><strong>PeerL</strong></td>
  <td><p class="line862">10.10.34.56</td>
</tr>
</tbody></table></div><span class="anchor" id="line-231"></span><span class="anchor" id="line-232"></span><p class="line874">Let's note a few more things about these peers: <span class="anchor" id="line-233"></span><span class="anchor" id="line-234"></span><div><table><tbody><tr>  <td><p class="line891"><em>Host</em></td>
  <td><p class="line891"><em>Local</em></td>
  <td><p class="line891"><em>Neighborhood</em></td>
  <td><p class="line891"><em>Matching IP Bits</em></td>
</tr>
<tr>  <td><span class="anchor" id="line-235"></span><p class="line891"><strong>PeerA</strong></td>
  <td><p class="line862">Yes</td>
  <td><p class="line862">10.12.34.0/24</td>
  <td><p class="line862">24</td>
</tr>
<tr>  <td><span class="anchor" id="line-236"></span><p class="line891"><strong>PeerB</strong></td>
  <td><p class="line862">Yes</td>
  <td><p class="line862">10.12.34.0/24</td>
  <td><p class="line862">24</td>
</tr>
<tr>  <td><span class="anchor" id="line-237"></span><p class="line891"><strong>PeerC</strong></td>
  <td><p class="line862">Yes</td>
  <td><p class="line862">10.12.34.0/24</td>
  <td><p class="line862">24</td>
</tr>
<tr>  <td><span class="anchor" id="line-238"></span><p class="line891"><strong>PeerD</strong></td>
  <td><p class="line862">No</td>
  <td><p class="line862">10.12.23.0/24</td>
  <td><p class="line862">16</td>
</tr>
<tr>  <td><span class="anchor" id="line-239"></span><p class="line891"><strong>PeerE</strong></td>
  <td><p class="line862">No</td>
  <td><p class="line862">10.12.23.0/24</td>
  <td><p class="line862">16</td>
</tr>
<tr>  <td><span class="anchor" id="line-240"></span><p class="line891"><strong>PeerF</strong></td>
  <td><p class="line862">No</td>
  <td><p class="line862">10.12.45.0/24</td>
  <td><p class="line862">16</td>
</tr>
<tr>  <td><span class="anchor" id="line-241"></span><p class="line891"><strong>PeerG</strong></td>
  <td><p class="line862">No</td>
  <td><p class="line862">10.12.45.0/24</td>
  <td><p class="line862">16</td>
</tr>
<tr>  <td><span class="anchor" id="line-242"></span><p class="line891"><strong>PeerH</strong></td>
  <td><p class="line862">No</td>
  <td><p class="line862">10.12.56.0/24</td>
  <td><p class="line862">16</td>
</tr>
<tr>  <td><span class="anchor" id="line-243"></span><p class="line891"><strong>PeerI</strong></td>
  <td><p class="line862">No</td>
  <td><p class="line862">10.12.56.0/24</td>
  <td><p class="line862">16</td>
</tr>
<tr>  <td><span class="anchor" id="line-244"></span><p class="line891"><strong>PeerJ</strong></td>
  <td><p class="line862">No</td>
  <td><p class="line862">10.11.23.0/24</td>
  <td><p class="line862">8</td>
</tr>
<tr>  <td><span class="anchor" id="line-245"></span><p class="line891"><strong>PeerK</strong></td>
  <td><p class="line862">No</td>
  <td><p class="line862">10.11.23.0/24</td>
  <td><p class="line862">8</td>
</tr>
<tr>  <td><span class="anchor" id="line-246"></span><p class="line891"><strong>PeerL</strong></td>
  <td><p class="line862">No</td>
  <td><p class="line862">10.10.34.0/24</td>
  <td><p class="line862">8</td>
</tr>
</tbody></table></div><span class="anchor" id="line-247"></span><span class="anchor" id="line-248"></span><p class="line874">The network topology might look like this: <span class="anchor" id="line-249"></span><span class="anchor" id="line-250"></span><p class="line867"><span class="anchor" id="line-251"></span><span class="anchor" id="line-252"></span><span class="anchor" id="line-253"></span><span class="anchor" id="line-254"></span><span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span><span class="anchor" id="line-257"></span><span class="anchor" id="line-258"></span><span class="anchor" id="line-259"></span><span class="anchor" id="line-260"></span><span class="anchor" id="line-261"></span><span class="anchor" id="line-262"></span><span class="anchor" id="line-263"></span><span class="anchor" id="line-264"></span><span class="anchor" id="line-265"></span><span class="anchor" id="line-266"></span><span class="anchor" id="line-267"></span><span class="anchor" id="line-268"></span><span class="anchor" id="line-269"></span><span class="anchor" id="line-270"></span><span class="anchor" id="line-271"></span><span class="anchor" id="line-272"></span><span class="anchor" id="line-273"></span><span class="anchor" id="line-274"></span><span class="anchor" id="line-275"></span><span class="anchor" id="line-276"></span><span class="anchor" id="line-277"></span><span class="anchor" id="line-278"></span><span class="anchor" id="line-279"></span><span class="anchor" id="line-280"></span><span class="anchor" id="line-281"></span><span class="anchor" id="line-282"></span><span class="anchor" id="line-283"></span><span class="anchor" id="line-284"></span><span class="anchor" id="line-285"></span><span class="anchor" id="line-286"></span><span class="anchor" id="line-287"></span><span class="anchor" id="line-288"></span><span class="anchor" id="line-289"></span><span class="anchor" id="line-290"></span><span class="anchor" id="line-291"></span><span class="anchor" id="line-292"></span><span class="anchor" id="line-293"></span><span class="anchor" id="line-294"></span><span class="anchor" id="line-295"></span><span class="anchor" id="line-296"></span><span class="anchor" id="line-297"></span><span class="anchor" id="line-298"></span><span class="anchor" id="line-299"></span><span class="anchor" id="line-300"></span><span class="anchor" id="line-301"></span><span class="anchor" id="line-302"></span><span class="anchor" id="line-303"></span><span class="anchor" id="line-304"></span><span class="anchor" id="line-305"></span><span class="anchor" id="line-306"></span><span class="anchor" id="line-307"></span><span class="anchor" id="line-308"></span><span class="anchor" id="line-309"></span><span class="anchor" id="line-310"></span><span class="anchor" id="line-311"></span><span class="anchor" id="line-312"></span><span class="anchor" id="line-313"></span><span class="anchor" id="line-314"></span><span class="anchor" id="line-315"></span><span class="anchor" id="line-316"></span><span class="anchor" id="line-317"></span><span class="anchor" id="line-318"></span><span class="anchor" id="line-319"></span><span class="anchor" id="line-320"></span><span class="anchor" id="line-321"></span><span class="anchor" id="line-322"></span><span class="anchor" id="line-323"></span><span class="anchor" id="line-324"></span><span class="anchor" id="line-325"></span><span class="anchor" id="line-326"></span><span class="anchor" id="line-327"></span><span class="anchor" id="line-328"></span><span class="anchor" id="line-329"></span><span class="anchor" id="line-330"></span><span class="anchor" id="line-331"></span><span class="anchor" id="line-332"></span><span class="anchor" id="line-333"></span><span class="anchor" id="line-334"></span><img src="PeerSelection%3Faction=AttachFile&amp;do=get&amp;target=autogenerated-52862e2ce8b36355a12053fbae8277525a5f042d.png" /><span class="anchor" id="line-335"></span><span class="anchor" id="line-336"></span><p class="line874">Before it begins retrieving the file, the caching agent has these latency records from previous interactions with peers: <span class="anchor" id="line-337"></span><span class="anchor" id="line-338"></span><div><table><tbody><tr>  <td><p class="line891"><em>Where</em></td>
  <td><p class="line891"><em>Recent Latency</em></td>
  <td><p class="line891"><em>Average Latency</em></td>
</tr>
<tr>  <td><span class="anchor" id="line-339"></span><p class="line891"><strong>PeerA</strong></td>
  <td><p class="line862">2ms</td>
  <td><p class="line862">1ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-340"></span><p class="line891"><strong>PeerD</strong></td>
  <td><p class="line891"><em>none</em></td>
  <td><p class="line862">4ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-341"></span><p class="line891"><strong>PeerF</strong></td>
  <td><p class="line862">5ms</td>
  <td><p class="line862">4ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-342"></span><p class="line891"><strong>PeerJ</strong></td>
  <td><p class="line891"><em>none</em></td>
  <td><p class="line862">10ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-343"></span><p class="line862">10.12.34.0/24</td>
  <td><p class="line891"><em>N/A</em></td>
  <td><p class="line862">1.5ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-344"></span><p class="line862">10.12.23.0/24</td>
  <td><p class="line891"><em>N/A</em></td>
  <td><p class="line862">4.5ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-345"></span><p class="line862">10.12.45.0/24</td>
  <td><p class="line891"><em>N/A</em></td>
  <td><p class="line862">5.5ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-346"></span><p class="line862">10.11.23.0/24</td>
  <td><p class="line891"><em>N/A</em></td>
  <td><p class="line862">11ms</td>
</tr>
</tbody></table></div><span class="anchor" id="line-347"></span><span class="anchor" id="line-348"></span><p class="line867"><em>(Note: These latency numbers are not based on any real measurements. They are simply meant to be easy to read and understand.)</em> <span class="anchor" id="line-349"></span><span class="anchor" id="line-350"></span><p class="line874">In order to make its first selection of peers to contact for retrieving the file, the agent will order the peers as follows: <span class="anchor" id="line-351"></span><span class="anchor" id="line-352"></span><ol type="1"><li><p class="line891"><strong>PeerB</strong> and <strong>PeerC</strong> <span class="anchor" id="line-353"></span><ul><li>Estimated latency: 1.5ms <span class="anchor" id="line-354"></span><ul><li>Based on latency data for the neighborhood <span class="anchor" id="line-355"></span></li></ul></li></ul></li><li><p class="line891"><strong>PeerA</strong> <span class="anchor" id="line-356"></span><ul><li>Estimated latency: 2ms <span class="anchor" id="line-357"></span><ul><li>Based on recent activity <span class="anchor" id="line-358"></span></li></ul></li></ul></li><li><p class="line891"><strong>PeerD</strong>, <strong>PeerH</strong>, and <strong>PeerI</strong> <span class="anchor" id="line-359"></span><ul><li><p class="line891"><strong>PeerD</strong> has an estimated latency: 4ms <span class="anchor" id="line-360"></span><ul><li>Overall average <span class="anchor" id="line-361"></span></li></ul></li><li><p class="line891"><strong>PeerH</strong>, and <strong>PeerI</strong> have no latency estimate available, but match the same number of leading IP bits as <strong>PeerD</strong> <span class="anchor" id="line-362"></span><ul><li>See &quot;Sorting Peers&quot; above for why peers with no latency data are handled this way <span class="anchor" id="line-363"></span></li></ul></li></ul></li><li><p class="line891"><strong>PeerE</strong> <span class="anchor" id="line-364"></span><ul><li>Estimated latency: 4.5ms <span class="anchor" id="line-365"></span><ul><li>Based on latency data for the neighborhood <span class="anchor" id="line-366"></span></li></ul></li></ul></li><li><p class="line891"><strong>PeerF</strong> <span class="anchor" id="line-367"></span><ul><li>Estimated latency: 5ms <span class="anchor" id="line-368"></span><ul><li>Based on recent activity <span class="anchor" id="line-369"></span></li></ul></li></ul></li><li><p class="line891"><strong>PeerG</strong> <span class="anchor" id="line-370"></span><ul><li>Estimated latency: 5.5ms <span class="anchor" id="line-371"></span><ul><li>Based on latency data for the neighborhood <span class="anchor" id="line-372"></span></li></ul></li></ul></li><li><p class="line891"><strong>PeerJ</strong> <span class="anchor" id="line-373"></span><ul><li>Estimated latency: 10ms <span class="anchor" id="line-374"></span><ul><li>Overall average <span class="anchor" id="line-375"></span></li></ul></li></ul></li><li><p class="line891"><strong>PeerK</strong> and <strong>PeerL</strong> <span class="anchor" id="line-376"></span><ul><li><p class="line891"><strong>PeerK</strong> has an estimated latency: 11ms <span class="anchor" id="line-377"></span><ul><li>Based on latency data for the neighborhood <span class="anchor" id="line-378"></span></li></ul></li><li><p class="line891"><strong>PeerL</strong> has no latency estimate available, but matches the same number of leading IP bits as <strong>PeerK</strong> <span class="anchor" id="line-379"></span><span class="anchor" id="line-380"></span></li></ul></li></ol><p class="line862">Assume the agent is configured to contact five peers in parallel (the default).  It will clearly select <strong>PeerB</strong>, <strong>PeerC</strong>, and <strong>PeerA</strong>.  It will then randomly select two of <strong>PeerD</strong>, <strong>PeerH</strong>, and <strong>PeerI</strong>.  For this example it will pick <strong>PeerD</strong> and <strong>PeerH</strong>.  The latency of those five parallel requests are: <span class="anchor" id="line-381"></span><span class="anchor" id="line-382"></span><div><table><tbody><tr>  <td><p class="line891"><strong>PeerA</strong></td>
  <td><p class="line862">1ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-383"></span><p class="line891"><strong>PeerB</strong></td>
  <td><p class="line862">2ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-384"></span><p class="line891"><strong>PeerC</strong></td>
  <td><p class="line862">2.5ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-385"></span><p class="line891"><strong>PeerD</strong></td>
  <td><p class="line862">3.5ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-386"></span><p class="line891"><strong>PeerH</strong></td>
  <td><p class="line862">4ms</td>
</tr>
</tbody></table></div><span class="anchor" id="line-387"></span><span class="anchor" id="line-388"></span><p class="line862">Recalling the discussion above about how the recent pseudo-averages will be computed and assuming <tt>past_weight</tt> is set to 2, we have this new latency data: <span class="anchor" id="line-389"></span><span class="anchor" id="line-390"></span><div><table><tbody><tr>  <td><p class="line891"><em>Where</em></td>
  <td><p class="line891"><em>Recent Latency</em></td>
  <td><p class="line891"><em>Average Latency</em></td>
</tr>
<tr>  <td><span class="anchor" id="line-391"></span><p class="line891"><strong>PeerA</strong></td>
  <td><p class="line862">1.67ms</td>
  <td><p class="line862">1ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-392"></span><p class="line891"><strong>PeerB</strong></td>
  <td><p class="line862">2ms</td>
  <td><p class="line862">2ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-393"></span><p class="line891"><strong>PeerC</strong></td>
  <td><p class="line862">2.5ms</td>
  <td><p class="line862">2.5ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-394"></span><p class="line891"><strong>PeerD</strong></td>
  <td><p class="line862">3.83ms</td>
  <td><p class="line862">3.99ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-395"></span><p class="line891"><strong>PeerF</strong></td>
  <td><p class="line862">5ms</td>
  <td><p class="line862">4ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-396"></span><p class="line891"><strong>PeerH</strong></td>
  <td><p class="line862">4ms</td>
  <td><p class="line862">4ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-397"></span><p class="line891"><strong>PeerJ</strong></td>
  <td><p class="line891"><em>none</em></td>
  <td><p class="line862">10ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-398"></span><p class="line862">10.12.34.0/24</td>
  <td><p class="line891"><em>N/A</em></td>
  <td><p class="line862">1.51ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-399"></span><p class="line862">10.12.23.0/24</td>
  <td><p class="line891"><em>N/A</em></td>
  <td><p class="line862">4.49ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-400"></span><p class="line862">10.12.45.0/24</td>
  <td><p class="line891"><em>N/A</em></td>
  <td><p class="line862">5.5ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-401"></span><p class="line862">10.11.23.0/24</td>
  <td><p class="line891"><em>N/A</em></td>
  <td><p class="line862">11ms</td>
</tr>
<tr>  <td><span class="anchor" id="line-402"></span><p class="line862">10.12.56.0/24</td>
  <td><p class="line891"><em>N/A</em></td>
  <td><p class="line862">4ms</td>
</tr>
</tbody></table></div><span class="anchor" id="line-403"></span><span class="anchor" id="line-404"></span><p class="line874">In order to make its second selection of peers to contact for retrieving the file, the agent will order the peers as follows: <span class="anchor" id="line-405"></span><span class="anchor" id="line-406"></span><ol type="1"><li><p class="line891"><strong>PeerA</strong> <span class="anchor" id="line-407"></span><ul><li>Estimated latency: 1.67ms <span class="anchor" id="line-408"></span></li></ul></li><li><p class="line891"><strong>PeerB</strong> <span class="anchor" id="line-409"></span><ul><li>Estimated latency: 2ms <span class="anchor" id="line-410"></span></li></ul></li><li><p class="line891"><strong>PeerC</strong> <span class="anchor" id="line-411"></span><ul><li>Estimated latency: 2.5ms <span class="anchor" id="line-412"></span></li></ul></li><li><p class="line891"><strong>PeerD</strong> <span class="anchor" id="line-413"></span><ul><li>Estimated latency: 3.83ms <span class="anchor" id="line-414"></span></li></ul></li><li><p class="line891"><strong>PeerH</strong> and <strong>PeerI</strong> <span class="anchor" id="line-415"></span><ul><li>Estimated latency: 4ms <span class="anchor" id="line-416"></span><ul><li><p class="line891"><strong>PeerI</strong> is from recent latency <span class="anchor" id="line-417"></span></li><li><p class="line891"><strong>PeerH</strong> is from its neighborhood's latency <span class="anchor" id="line-418"></span></li></ul></li></ul></li><li><p class="line891"><strong>PeerE</strong> <span class="anchor" id="line-419"></span><ul><li>Estimated latency: 4.49ms <span class="anchor" id="line-420"></span></li></ul></li><li><p class="line891"><strong>PeerF</strong> <span class="anchor" id="line-421"></span><ul><li>Estimated latency: 5ms <span class="anchor" id="line-422"></span></li></ul></li><li><p class="line891"><strong>PeerG</strong> <span class="anchor" id="line-423"></span><ul><li>Estimated latency: 5.5ms <span class="anchor" id="line-424"></span></li></ul></li><li><p class="line891"><strong>PeerJ</strong> <span class="anchor" id="line-425"></span><ul><li>Estimated latency: 10ms <span class="anchor" id="line-426"></span></li></ul></li><li><p class="line891"><strong>PeerK</strong> and <strong>PeerL</strong> <span class="anchor" id="line-427"></span><ul><li><p class="line891"><strong>PeerK</strong> has an estimated latency: 11ms <span class="anchor" id="line-428"></span></li><li><p class="line891"><strong>PeerL</strong> has no latency estimate available, but matches the same number of leading IP bits as <strong>PeerK</strong> <span class="anchor" id="line-429"></span><span class="anchor" id="line-430"></span></li></ul></li></ol><p class="line862">So the second five peers selected will be: <strong>PeerA</strong>, <strong>PeerB</strong>, <strong>PeerC</strong>, <strong>PeerD</strong> and either <strong>PeerH</strong> or <strong>PeerI</strong>. <span class="anchor" id="line-431"></span><span class="anchor" id="line-432"></span><p class="line867">
<h2 id="Implementation_Notes">Implementation Notes</h2>
<span class="anchor" id="line-433"></span><span class="anchor" id="line-434"></span><p class="line874">I had planned on keeping a recent pseudo-average for each peer the agent had communicated in the past and for the server, in addition to all-time averages for both.  I had not planned to keep a recent pseudo-average for each network neighborhood.  My thinking was that short-term changes in latency were more likely for individual hosts than for entire network neighborhoods, though that's a fuzzy argument and may not be true. <span class="anchor" id="line-435"></span><span class="anchor" id="line-436"></span><p class="line862">The implementation is making it simpler to also keep a recent pseudo-average for each network neighborhood.  I can't convince myself there's a good reason to avoid that, so I'm just going to keep the neighborhood recent pseudo-averages.  However, it does seem like the <tt>past_weight</tt> setting should be higher for network neighborhoods than individual peers (to keep single slow peers from quickly dragging down the entire neighborhood's pseudo-average).  They'll be separately configurable, and the neighborhood <tt>past_weight</tt> will default to twice the peer <tt>past_weight</tt>. <span class="anchor" id="line-437"></span><span class="anchor" id="bottom"></span></div>
<div id="pagebottom"></div>
</div>


<div id="footer">
<ul id="credits">
<li><a href="http://moinmo.in/" title="This site uses the MoinMoin Wiki software.">MoinMoin Powered</a></li><li><a href="http://moinmo.in/Python" title="MoinMoin is written in Python.">Python Powered</a></li><li><a href="http://moinmo.in/GPL" title="MoinMoin is GPL licensed.">GPL licensed</a></li><li><a href="http://validator.w3.org/check?uri=referer" title="Click here to validate this page.">Valid HTML 4.01</a></li>
</ul>


</div>
</body>
</html>

