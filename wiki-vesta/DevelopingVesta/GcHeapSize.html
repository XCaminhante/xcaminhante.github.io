<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="robots" content="index,nofollow">

<title>DevelopingVesta/GcHeapSize - Vesta Wiki</title>
<script type="text/javascript" src="../moin_static199/common/js/common.js"></script>

<script type="text/javascript">
<!--
var search_hint = "Search";
//-->
</script>


<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="../moin_static199/vesta/css/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="../moin_static199/vesta/css/screen.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="print" href="../moin_static199/vesta/css/print.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="projection" href="../moin_static199/vesta/css/projection.css">

<!-- css only for MS IE6/IE7 browsers -->
<!--[if lt IE 8]>
   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="../moin_static199/vesta/css/msie.css">
<![endif]-->


<link rel="alternate" title="Vesta Wiki: DevelopingVesta/GcHeapSize" href="GcHeapSize%3Fdiffs=1&amp;show_att=1&amp;action=rss_rc&amp;unique=0&amp;page=DevelopingVesta%252FGcHeapSize&amp;ddiffs=1.html" type="application/rss+xml">


<link rel="Start" href="FrontPage.html">
<link rel="Alternate" title="Wiki Markup" href="GcHeapSize%3Faction=raw.html">
<link rel="Alternate" media="print" title="Print View" href="GcHeapSize%3Faction=print.html">
<link rel="Up" href="DevelopingVesta.html">
<link rel="Search" href="FindPage.html">
<link rel="Index" href="TitleIndex.html">
<link rel="Glossary" href="WordIndex.html">
<link rel="Help" href="HelpOnFormatting.html">
</head>

<body  lang="en" dir="ltr">

<div id="header">

<form id="searchform" method="get" action="GcHeapSize.html">
<div>
<input type="hidden" name="action" value="fullsearch">
<input type="hidden" name="context" value="180">
<label for="searchinput">Search:</label>
<input id="searchinput" type="text" name="value" value="" size="20"
    onfocus="searchFocus(this)" onblur="searchBlur(this)"
    onkeyup="searchChange(this)" onchange="searchChange(this)" alt="Search">
<input id="titlesearch" name="titlesearch" type="submit"
    value="Titles" alt="Search Titles">
<input id="fullsearch" name="fullsearch" type="submit"
    value="Text" alt="Search Full Text">
</div>
</form>
<script type="text/javascript">
<!--// Initialize search form
var f = document.getElementById('searchform');
f.getElementsByTagName('label')[0].style.display = 'none';
var e = document.getElementById('searchinput');
searchChange(e);
searchBlur(e);
//-->
</script>

<div id="logo"><a href="FrontPage.html"><img src="wiki/vesta/img/1line.png" alt="Vesta" height=44 width=202></a></div>
<div id="locationline">

<ul id="pagelocation">
<li><a href="DevelopingVesta.html">DevelopingVesta</a></li><li><a href="GcHeapSize.html">GcHeapSize</a></li>
</ul>

</div>
</div>

<div id="sidebar">
<div class="sidepanel">
<h1>Wiki</h1>

<ul id="navibar">
<li class="wikilink"><a href="RecentChanges.html">RecentChanges</a></li><li class="wikilink"><a href="FindPage.html">FindPage</a></li><li class="wikilink"><a href="HelpContents.html">HelpContents</a></li><li class="current"><a href="GcHeapSize.html">GcHeapSize</a></li>
</ul>

</div>
<div class="sidepanel">
<h1>User</h1>
<ul id="username"><li><a href="GcHeapSize%3Faction=login.html" id="login" rel="nofollow">Login</a></li></ul>
</div>
</div>

<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><span class="anchor" id="line-5"></span><p class="line867"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li>
<a href="GcHeapSize.html#Reducing_the_heap_size_of_GC_programs">Reducing the heap size of GC programs</a><ol><li>
<a href="GcHeapSize.html#Actually_free_heap_blocks_in_GC_pograms">Actually free heap blocks in GC pograms</a></li><li>
<a href="GcHeapSize.html#Help_the_GC_by_clearing_pointers">Help the GC by clearing pointers</a></li><li>
<a href="GcHeapSize.html#Use_the_garbage_collector.27s_explicitly-typed_allocation_interface">Use the garbage collector's explicitly-typed allocation interface</a></li><li>
<a href="GcHeapSize.html#Explicitly_collect_garbage_during_idle_periods">Explicitly collect garbage during idle periods</a></li><li>
<a href="GcHeapSize.html#GC_Tuning_Parameters">GC Tuning Parameters</a></li><li>
<a href="GcHeapSize.html#GC_Incremental_Mode">GC Incremental Mode</a></li></ol></li><li>
<a href="GcHeapSize.html#Completed_Changes">Completed Changes</a><ol><li>
<a href="GcHeapSize.html#Disable_ALL_INTERIOR_POINTERS_in_the_Garbage_Collector_Configuration">Disable ALL_INTERIOR_POINTERS in the Garbage Collector Configuration</a></li><li>
<a href="GcHeapSize.html#Use_Atom_more_and_Text_less_in_the_Evaluator">Use Atom more and Text less in the Evaluator</a></li><li>
<a href="GcHeapSize.html#Don.27t_accumulate_a_string_into_a_buffer_in_memory_just_to_fingerprint_it">Don't accumulate a string into a buffer in memory just to fingerprint it</a></li><li>
<a href="GcHeapSize.html#Make_More_Garbage_Collector_Settings_Accessible">Make More Garbage Collector Settings Accessible</a></li><li>
<a href="GcHeapSize.html#Set_GC_max_retries_to_1">Set GC_max_retries to 1</a></li><li>
<a href="GcHeapSize.html#Eliminate_the_use_of_ostringstream">Eliminate the use of ostringstream</a></li></ol></li><li>
<a href="GcHeapSize.html#List_of_programs_using_GC">List of programs using GC</a></li></ol></div> <span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span><p class="line867">
<h1 id="Reducing_the_heap_size_of_GC_programs">Reducing the heap size of GC programs</h1>
<span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line874">Several programs in Vesta use the Borhm garbage collector library.  We have had some problems with garbage collected programs growing to <span class="anchor" id="line-10"></span>extremely large amounts of memory.  Mostly this has been the evaluator <span class="anchor" id="line-11"></span>and the cache server, though with complicated instructions the <span class="anchor" id="line-12"></span>rpelicator has been known to have this problem as well. <span class="anchor" id="line-13"></span><span class="anchor" id="line-14"></span><p class="line874">This page lists a variety of options for attacking this problem as well as some notes on what we've already done. <span class="anchor" id="line-15"></span><span class="anchor" id="line-16"></span><p class="line867">
<h2 id="Actually_free_heap_blocks_in_GC_pograms">Actually free heap blocks in GC pograms</h2>
<span class="anchor" id="line-17"></span><span class="anchor" id="line-18"></span><p class="line874">The basics library provides a delete operator which simply drops all <span class="anchor" id="line-19"></span>heap blocks on the floor.  However the garbage collector does provide <span class="anchor" id="line-20"></span>the ability to explicitly free heap blocks.  We could make the delete <span class="anchor" id="line-21"></span>operator call this.  This would cause memory to be reclaimed earlier, <span class="anchor" id="line-22"></span>reducing the rate of heap growth. <span class="anchor" id="line-23"></span><span class="anchor" id="line-24"></span><p class="line874">The problem with doing this is that the current code base has <span class="anchor" id="line-25"></span>developed under the assumption that the delete operator doesn't <span class="anchor" id="line-26"></span>actually free anything.  We would need to audit every use of the <span class="anchor" id="line-27"></span>delete operator in every application using garbage collection <span class="anchor" id="line-28"></span>(including all the libraries they use) to make sure that there is no <span class="anchor" id="line-29"></span>possibility of additional references to the same block.  In cases <span class="anchor" id="line-30"></span>where there may be additional references, the delete operator could <span class="anchor" id="line-31"></span>simply be removed. <span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><p class="line874">This may be difficult in shared code (such as that in libraries) which <span class="anchor" id="line-34"></span>needs to work both with and without garbage collection.  In such <span class="anchor" id="line-35"></span>cases, we may need to have the library alter its code at compile time <span class="anchor" id="line-36"></span>based on whether garbage collection is enabled, or check at run-time <span class="anchor" id="line-37"></span>whether garbage collection is being used. <span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><p class="line867">
<h2 id="Help_the_GC_by_clearing_pointers">Help the GC by clearing pointers</h2>
<span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line874">Since the garbage collector searches for pointers, any time we can <span class="anchor" id="line-42"></span>clear a pointer we no longer need it can help keep the garbage <span class="anchor" id="line-43"></span>collector from treating garbage as non-garbage. <span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><p class="line874">When exiting a stack frame, local pointer variables can be cleared. <span class="anchor" id="line-46"></span>Stack-allocated instances will have their destrucotrs called, so it <span class="anchor" id="line-47"></span>would be good if they cleared instance member variables which are <span class="anchor" id="line-48"></span>pointers.  (For example, the ListT template class in the evalautor, <span class="anchor" id="line-49"></span>which is the actualy type of the commonly used Context typedef, could <span class="anchor" id="line-50"></span>have a destructor which cleared its list and last member variables.) <span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><p class="line867">
<h2 id="Use_the_garbage_collector.27s_explicitly-typed_allocation_interface">Use the garbage collector's explicitly-typed allocation interface</h2>
<span class="anchor" id="line-53"></span><span class="anchor" id="line-54"></span><p class="line874">By default the garbage collector assumes htat any bytes in an <span class="anchor" id="line-55"></span>allocated heap block may contain pointers.  This allows data to be <span class="anchor" id="line-56"></span>mistaknely treated as pointer references to heap blocks which would <span class="anchor" id="line-57"></span>otherwise be treated as garbage. <span class="anchor" id="line-58"></span><span class="anchor" id="line-59"></span><p class="line874">We took steps to make this less likely by changing the garbage <span class="anchor" id="line-60"></span>collectors options to keep it from treating pointers to any position <span class="anchor" id="line-61"></span>within a heap block as valid references (disabling its <span class="anchor" id="line-62"></span><tt>ALL_INTERIOR_POINTERS</tt> configuration option).  However this only <span class="anchor" id="line-63"></span>reduces the propbability of mis-identifying data as pointers.  It does <span class="anchor" id="line-64"></span>not completely eliminate the problem. <span class="anchor" id="line-65"></span><span class="anchor" id="line-66"></span><p class="line874">The garbage collector allows a caller to provide an explicit <span class="anchor" id="line-67"></span>specification of where the pointers are within a heap block.  This <span class="anchor" id="line-68"></span>makes it possible to avoid mis-identifying data as pointers in blocks <span class="anchor" id="line-69"></span>allocated using this method. <span class="anchor" id="line-70"></span><span class="anchor" id="line-71"></span><p class="line874">This is unfortunately not a simple matter, especially for C++ classes. <span class="anchor" id="line-72"></span>Some initial work has been done with this.  See the currently <span class="anchor" id="line-73"></span>abandoned branches: <span class="anchor" id="line-74"></span><span class="anchor" id="line-75"></span><ul><li><p class="line891"><a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/basics/basics/26.typed_gc_alloc">/vesta/vestasys.org/basics/basics/26.typed_gc_alloc</a> <span class="anchor" id="line-76"></span></li><li><p class="line891"><a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/vesta/eval/66.typed_gc_alloc">/vesta/vestasys.org/vesta/eval/66.typed_gc_alloc</a> <span class="anchor" id="line-77"></span><span class="anchor" id="line-78"></span></li></ul><p class="line862">And the tracker entry <a class="https" href="https://sourceforge.net/tracker/index.php?func=detail&amp;aid=1065404&amp;group_id=34164&amp;atid=410430">Mark more memory as pointer-free with garbage collector</a>. <span class="anchor" id="line-79"></span><span class="anchor" id="line-80"></span><p class="line867">
<h2 id="Explicitly_collect_garbage_during_idle_periods">Explicitly collect garbage during idle periods</h2>
<span class="anchor" id="line-81"></span><span class="anchor" id="line-82"></span><p class="line874">Collecting garbage requires pausing the entire application.  Normally <span class="anchor" id="line-83"></span>the garbage collector tries to automatically determine when it should <span class="anchor" id="line-84"></span>do this.  It tries to avoid doing it very often, as while the <span class="anchor" id="line-85"></span>applicaiton is collecitng garbage it's not getting any &quot;real&quot; work <span class="anchor" id="line-86"></span>done. <span class="anchor" id="line-87"></span><span class="anchor" id="line-88"></span><p class="line874">Some of the GC applications have periods where they're mostly idle <span class="anchor" id="line-89"></span>anyway.  It would be possible to explicitly invoke the gabrage <span class="anchor" id="line-90"></span>collector during these periods. <span class="anchor" id="line-91"></span><span class="anchor" id="line-92"></span><p class="line874">For example, when the vrepl is waiting for the repository to copy an <span class="anchor" id="line-93"></span>immutable version from a peer repository, it's completely idle until <span class="anchor" id="line-94"></span>the RPC to the repository returns.  When the evaluator is performing a <span class="anchor" id="line-95"></span>call the cache server, it is simiarly stalled until the RPC to the <span class="anchor" id="line-96"></span>cache server returns. <span class="anchor" id="line-97"></span><span class="anchor" id="line-98"></span><p class="line874">However, implementing this would require a fair amount of care.  A <span class="anchor" id="line-99"></span>multi-threaded program would have to have all threads waiting for a <span class="anchor" id="line-100"></span>response from a server before it would really be idle.  An evaluator <span class="anchor" id="line-101"></span>waiting for a tool invocation to complete is not idle, as it still <span class="anchor" id="line-102"></span>needs to service incoming Tool<strong></strong>Directory<strong></strong>Server requests.  The SRPC <span class="anchor" id="line-103"></span>layer would have to signal some other code that it is blocked waiting <span class="anchor" id="line-104"></span>for a response (perhps with a condition variable) , and similarly <span class="anchor" id="line-105"></span>signal when it is no longer blocked waiting for a reponse.  When <span class="anchor" id="line-106"></span>receiving such a signal that a thread is blocking, it would not be <span class="anchor" id="line-107"></span>appropriate to start garbage collection immediately, as the SRPC layer <span class="anchor" id="line-108"></span>could only send such a signal <strong>before</strong> it begins waiting. <span class="anchor" id="line-109"></span><span class="anchor" id="line-110"></span><p class="line867">
<h2 id="GC_Tuning_Parameters">GC Tuning Parameters</h2>
<span class="anchor" id="line-111"></span><span class="anchor" id="line-112"></span><p class="line874">The garbage collector has some parameters which can give us some additional control over how it works which may allow us to improve the situation. <span class="anchor" id="line-113"></span><span class="anchor" id="line-114"></span><p class="line862">One parameter is <tt>GC_free_space_divisor</tt> which controls how the garbage collector decides whether to expand the heap or perform a garbage collection.  To quote <a class="http" href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/gcdescr.html">the documentation</a>: <span class="anchor" id="line-115"></span><span class="anchor" id="line-116"></span><ul><li style="list-style-type:none"><p class="line891"><em>If the total amount of allocation since the last collection is less than the heap size divided by <tt>GC_free_space_divisor</tt>, we try to expand the heap. Otherwise, we initiate a garbage collection. This ensures that the amount of garbage collection work per allocated byte remains constant.</em> <span class="anchor" id="line-117"></span><span class="anchor" id="line-118"></span></li></ul><p class="line867"><tt>GC_free_space_divisor</tt> defaults to 3.  Increasing it would make garbage collections occur more frequently and heap expansions occur less frequently.  This could help keep the heap size from growing as large as it does, and may be warranted given how much garbage the evaluator generates.  However, there would be some performance cost as it would make the evaluator spend more time collecting garbage and less time doing &quot;real work&quot;. <span class="anchor" id="line-119"></span><span class="anchor" id="line-120"></span><p class="line862">Another setting is <tt>GC_max_retries</tt> which is: <span class="anchor" id="line-121"></span><span class="anchor" id="line-122"></span><ul><li style="list-style-type:none"><p class="line891"><em>The maximum number of GCs attempted before reporting out of memory after heap expansion fails.</em> <span class="anchor" id="line-123"></span><span class="anchor" id="line-124"></span></li></ul><p class="line862">The default value is 0, though <a href="GcHeapSize.html#GC_max_retries_set_to_1">we now initialize it to 1</a>.  It's not clear whether values higher than 1 would have any effect. <span class="anchor" id="line-125"></span><span class="anchor" id="line-126"></span><p class="line862">Another potentially interesting setting is <tt>GC_dont_expand</tt>, described as follows: <span class="anchor" id="line-127"></span><span class="anchor" id="line-128"></span><ul><li style="list-style-type:none"><p class="line891"><em>Dont expand heap unless explicitly requested or forced to.</em> <span class="anchor" id="line-129"></span><span class="anchor" id="line-130"></span></li></ul><p class="line862">I've never tried using this, but my impression is that it would make the garbage collector always try to collect garbage before trying to expand the heap.  It sounds theoretically equivalent to setting <tt>GC_free_space_divisor</tt> to infinity (i.e. always try to perform a garbage collection before resorting to expanding the heap). <span class="anchor" id="line-131"></span><span class="anchor" id="line-132"></span><p class="line867"><a href="GcHeapSize.html#GC_config_env_vars">We've now made these settable with environment variables.</a> <span class="anchor" id="line-133"></span><span class="anchor" id="line-134"></span><p class="line862">There are also other settings in <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/libs/gc/6.4/8/src/gc6.4/include/gc.h">gc.h</a>.  Also see <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/libs/gc/6.4/8/src/gc6.4/doc/README.environment">README.environment</a>. <span class="anchor" id="line-135"></span><span class="anchor" id="line-136"></span><p class="line862">We might want to adjust some of these settings as th heap increases in size, essentially making them a function of the heap size.  For example, if we increased <tt>GC_free_space_divisor</tt> as the heap got larger, we could favor garbage collection over heap expansion more.  Another possibility would be setting <tt>GC_dont_expand</tt> after the heap size crosses some threshold. <span class="anchor" id="line-137"></span><span class="anchor" id="line-138"></span><p class="line867">
<h2 id="GC_Incremental_Mode">GC Incremental Mode</h2>
<span class="anchor" id="line-139"></span><span class="anchor" id="line-140"></span><p class="line862">The garbage collector has an <em>incremental mode</em> which allows garbage collection to proceed in parallel with other work.  It can be enabled by setting the <tt>GC_ENABLE_INCREMENTAL</tt> environment variable (though it can also be explicitly enabled by a function call to <tt>GC_enable_incremental</tt>.  In theory, this could reduce heap expansion by collecting more garbage sooner.  This could also be combined with other approaches, for example by calling <tt>GC_collect_a_little</tt> when waiting for a response from a server. <span class="anchor" id="line-141"></span><span class="anchor" id="line-142"></span><p class="line862">Unfortunately, tests with the evaluator have shown that this feature actually <strong>increases</strong> memory use.  In small tests (builds of publicly-available models like Vesta release builds typically using 10s of MB of memory), we found these approximate differences: <span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><ul><li>Total memory size at process exit: 19% increase <span class="anchor" id="line-145"></span></li><li>Resident memory size at process exit: 46% increase <span class="anchor" id="line-146"></span></li><li>GC heap size at process exit: 39% increase <span class="anchor" id="line-147"></span><span class="anchor" id="line-148"></span></li></ul><p class="line874">In larger tests (builds at Intel typically using a small number of GB of memory) the results were even worse: <span class="anchor" id="line-149"></span><span class="anchor" id="line-150"></span><ul><li>Total memory size at process exit: 67% increase <span class="anchor" id="line-151"></span></li><li>Resident memory size at process exit: 48% increase <span class="anchor" id="line-152"></span></li><li>GC heap size at process exit: 43% increase <span class="anchor" id="line-153"></span><span class="anchor" id="line-154"></span></li></ul><p class="line874">Based on these results, we have left incremental garbage collection mode disabled. <span class="anchor" id="line-155"></span><span class="anchor" id="line-156"></span><p class="line867">
<h1 id="Completed_Changes">Completed Changes</h1>
<span class="anchor" id="line-157"></span><span class="anchor" id="line-158"></span><p class="line867">
<h2 id="Disable_ALL_INTERIOR_POINTERS_in_the_Garbage_Collector_Configuration">Disable ALL_INTERIOR_POINTERS in the Garbage Collector Configuration</h2>
<span class="anchor" id="line-159"></span><span class="anchor" id="line-160"></span><p class="line874">Some time ago, we disabled the garbage collector's <span class="anchor" id="line-161"></span><tt>ALL_INTERIOR_POINTERS</tt> configuration option.  This makes it less <span class="anchor" id="line-162"></span>likely for data to be mis-identified as a pointer and cause heap <span class="anchor" id="line-163"></span>blocks to be kept when they're really garbage.  (Note that this only <span class="anchor" id="line-164"></span>reduces the propbability, it does not completely eliminate the <span class="anchor" id="line-165"></span>problem.) <span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span><p class="line874">See: <span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><ul><li><p class="line891"><a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/basics/basics/26.turnoff_int_pointers">basics/basics/26.turnoff_int_pointers</a> <span class="anchor" id="line-170"></span></li><li><p class="line891"><a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/libs/gc/6.4/3.turnoff_int_pointers">libs/gc/6.4/3.turnoff_int_pointers</a> <span class="anchor" id="line-171"></span></li><li><p class="line891"><a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/vesta/cache/43.intrvl_mask">vesta/cache/43.intrvl_mask</a> <span class="anchor" id="line-172"></span><span class="anchor" id="line-173"></span></li></ul><p class="line867">
<h2 id="Use_Atom_more_and_Text_less_in_the_Evaluator">Use Atom more and Text less in the Evaluator</h2>
<span class="anchor" id="line-174"></span><span class="anchor" id="line-175"></span><p class="line874">The Atom class in generics library is a subclass of the Text class <span class="anchor" id="line-176"></span>from the basics library.  Atom uses a global string table to avoid <span class="anchor" id="line-177"></span>storing the same string more than once. <span class="anchor" id="line-178"></span><span class="anchor" id="line-179"></span><p class="line874">Applications which manipulate text strings can use this to avoid the <span class="anchor" id="line-180"></span>need to store the same string multiple times. <span class="anchor" id="line-181"></span><span class="anchor" id="line-182"></span><p class="line862">With <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/vesta/eval/80">eval/80</a> and <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/vesta/cache/50">cache/50</a>, the evaluator uses Atom rather than Text in a few key places: <span class="anchor" id="line-183"></span><span class="anchor" id="line-184"></span><ul><li><p class="line862">Member variables in subclasses of <tt>ExprC</tt> (which are used for the in-memory representation of parsed SDL code): <tt>NameEC</tt>, <tt>ApplyOpEC</tt>, <tt>ApplyUnOpEC</tt>, <tt>FileEC</tt>, <tt>PrimitiveEC</tt>, <tt>FuncEC</tt>, <tt>BaseTEC</tt> <span class="anchor" id="line-185"></span></li><li><p class="line862">The elements of the dependency paths.  <tt>ArcSeq</tt> in <tt>Dep.H</tt> is actully an <tt>FV2::T</tt> from <tt>FV2.H</tt> in the cache package, which is now a subclass of <tt>AtomSeq</tt> from generics. <span class="anchor" id="line-186"></span></li><li><p class="line862">The &quot;name&quot; member variable of the <tt>AssocVC</tt> data type (which is used for both assigned variables and binding elements) <span class="anchor" id="line-187"></span><span class="anchor" id="line-188"></span></li></ul><p class="line862">Thes changes were started in <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/vesta/cache/49.Atom_FV">cache/49.Atom_FV</a> and <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/vesta/eval/79.Atom">eval/79.Atom</a>. <span class="anchor" id="line-189"></span><span class="anchor" id="line-190"></span><p class="line867">
<h2 id="Don.27t_accumulate_a_string_into_a_buffer_in_memory_just_to_fingerprint_it">Don't accumulate a string into a buffer in memory just to fingerprint it</h2>
<span class="anchor" id="line-191"></span><span class="anchor" id="line-192"></span><p class="line874">In a few places the evaluator will compute a fingerprint by printing <span class="anchor" id="line-193"></span>some text to a stream: <span class="anchor" id="line-194"></span><span class="anchor" id="line-195"></span><ul><li><p class="line891"><tt>FuncEC::FingerPrint</tt> (in Expr.C) <span class="anchor" id="line-196"></span></li><li><p class="line891"><tt>FingerPrint(Expr&nbsp;expr)</tt> (in Expr.C) <span class="anchor" id="line-197"></span><span class="anchor" id="line-198"></span></li></ul><p class="line862">It used to used <tt>Basics::OBufStream</tt>, accumulating the test in <span class="anchor" id="line-199"></span>heap blocks and then fingerprinting it once done.  Now it uses the <span class="anchor" id="line-200"></span><tt>FP::FPStream</tt> class which fingerprints bytes as they are written. <span class="anchor" id="line-201"></span><span class="anchor" id="line-202"></span><p class="line867"><tt>FP::FPStream</tt> was introduced in <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/vesta/fp/17">fp/17</a> and the evaluator started using it in <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/vesta/eval/80">eval/80</a>. <span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span><p class="line867"><span class="anchor" id="GC_config_env_vars"></span> <span class="anchor" id="line-205"></span>
<h2 id="Make_More_Garbage_Collector_Settings_Accessible">Make More Garbage Collector Settings Accessible</h2>
<span class="anchor" id="line-206"></span><span class="anchor" id="line-207"></span><p class="line862">To make it easier to experiment with the garbage collector's settings, <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/basics/basics/33">basics/33</a> made a few more settable with environment variables: <span class="anchor" id="line-208"></span><span class="anchor" id="line-209"></span><dl><dt>GC_MAX_RETRIES</dt><dd><p class="line862">Sets <tt>GC_max_retries</tt>, accepts values between 1 and 10 <span class="anchor" id="line-210"></span><span class="anchor" id="line-211"></span></dd><dt>GC_FREE_SPACE_DIVISOR</dt><dd><p class="line862">Sets <tt>GC_free_space_divisor</tt>, accepts values between 3 and 100 <span class="anchor" id="line-212"></span><span class="anchor" id="line-213"></span></dd><dt>GC_DONT_EXPAND</dt><dd><p class="line862">If set (to any value), sets <tt>GC_dont_expand</tt> to 1 <span class="anchor" id="line-214"></span><span class="anchor" id="line-215"></span></dd><dt>GC_ENV_VERBOSE</dt><dd><p class="line862">If set, the code in <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/basics/basics">the basics library</a> produces output about the settings being used.  (This does not affect the code in <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/libs/gc">the garbage collector library itself</a> which uses <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/libs/gc/6.4/8/src/gc6.4/doc/README.environment">other environment variables</a>.) <span class="anchor" id="line-216"></span><span class="anchor" id="line-217"></span></dd></dl><p class="line867"><span class="anchor" id="GC_max_retries_set_to_1"></span> <span class="anchor" id="line-218"></span>
<h2 id="Set_GC_max_retries_to_1">Set GC_max_retries to 1</h2>
<span class="anchor" id="line-219"></span><span class="anchor" id="line-220"></span><p class="line874">To make sure the garbage collector doesn't give up immediately when it <span class="anchor" id="line-221"></span>fails to expand the heap, we set <tt>GC_max_retries</tt> to a minimum of <span class="anchor" id="line-222"></span>1 as of <a class="http" href="http://pub.vestasys.org/cgi-bin/vestaweb?path=/vesta/vestasys.org/basics/basics/33">basics/33</a>. <span class="anchor" id="line-223"></span><span class="anchor" id="line-224"></span><p class="line867">
<h2 id="Eliminate_the_use_of_ostringstream">Eliminate the use of ostringstream</h2>
<span class="anchor" id="line-225"></span><span class="anchor" id="line-226"></span><p class="line862">Some implementations of the standard <tt>ostringstream</tt> class (notably <span class="anchor" id="line-227"></span>the gcc implementation) cause a lot of heap allocations (and are <span class="anchor" id="line-228"></span>generally inefficient).  These implementations tend to allocate just <span class="anchor" id="line-229"></span>enough space for each successive write, copying the bytes form the <span class="anchor" id="line-230"></span>previous heap block and freeing the previosu heap block.  Since the <span class="anchor" id="line-231"></span>basics library provides a delete operator which simply drops all heap <span class="anchor" id="line-232"></span>blocks on the floor, this creates a lot of allocations and garbage. <span class="anchor" id="line-233"></span>(Creating less garbage would keep the rate of heap growth down.) <span class="anchor" id="line-234"></span><span class="anchor" id="line-235"></span><p class="line874">The basics library provides an alternative class <span class="anchor" id="line-236"></span>(<tt>Basics::OBufStream</tt>) which performs far fewer allocations and <span class="anchor" id="line-237"></span>thus produces less garbage in general. <span class="anchor" id="line-238"></span><span class="anchor" id="line-239"></span><p class="line867"><strong><a class="nonexistent" href="../SimonPeffers.html">SimonPeffers</a></strong>: I looked at all uses of ostringstream that I could find in  <span class="anchor" id="line-240"></span>Vesta and found that all uses were for printing error messages. I don't think  <span class="anchor" id="line-241"></span>fixing these would reduce the heap size much. <span class="anchor" id="line-242"></span><span class="anchor" id="line-243"></span><p class="line867"><strong><a href="../KenSchalk.html">KenSchalk</a></strong>: I'm not sure when we completely eliminated it, but <span class="anchor" id="line-244"></span><tt>ostringstream</tt> isn't used in the Vesta code any more. <span class="anchor" id="line-245"></span><span class="anchor" id="line-246"></span><p class="line867">
<h1 id="List_of_programs_using_GC">List of programs using GC</h1>
<span class="anchor" id="line-247"></span><span class="anchor" id="line-248"></span><p class="line874">Some of the changes outlined above could have a pervasive effect on all programs which use garbage collection.  When making such a change, every program which uses garbage collection should be checked to make sure it still works. <span class="anchor" id="line-249"></span><span class="anchor" id="line-250"></span><p class="line874">Here's a hopefully complete list of programs using the garbage collector: <span class="anchor" id="line-251"></span><span class="anchor" id="line-252"></span><ul><li>All programs in the eval package: <span class="anchor" id="line-253"></span><ul><li><p class="line891"><tt>vesta</tt> (the evaluator) <span class="anchor" id="line-254"></span></li><li><p class="line862">Pickle<strong></strong>Stats <span class="anchor" id="line-255"></span></li></ul></li><li>All programs in the repltools package: <span class="anchor" id="line-256"></span><ul><li><p class="line891"><tt>vrepl</tt> (the replicator) <span class="anchor" id="line-257"></span></li><li>vmaster <span class="anchor" id="line-258"></span></li><li>vglob <span class="anchor" id="line-259"></span></li><li>vcheckagreement <span class="anchor" id="line-260"></span></li></ul></li><li>All programs in the cache server package: <span class="anchor" id="line-261"></span><ul><li><p class="line891"><tt>VCache</tt> (the cache server) <span class="anchor" id="line-262"></span></li><li><p class="line862">VCache<strong></strong>Monitor <span class="anchor" id="line-263"></span></li><li><p class="line862">Chkpt<strong></strong>Cache <span class="anchor" id="line-264"></span></li><li><p class="line862">Flush<strong></strong>Cache <span class="anchor" id="line-265"></span></li><li><p class="line862">VCache<strong></strong>Stats <span class="anchor" id="line-266"></span></li><li><p class="line862">Print<strong></strong>Cache<strong></strong>Val <span class="anchor" id="line-267"></span></li><li>PrintMPKFile <span class="anchor" id="line-268"></span></li><li><p class="line862">Print<strong></strong>Cache<strong></strong>Log <span class="anchor" id="line-269"></span></li><li><p class="line862">Print<strong></strong>Graph<strong></strong>Log <span class="anchor" id="line-270"></span></li><li><p class="line862">Test<strong></strong>Cache <span class="anchor" id="line-271"></span></li><li><p class="line862">Test<strong></strong>Cache<strong></strong>Random <span class="anchor" id="line-272"></span></li><li><p class="line862">Test<strong></strong>Cache<strong></strong>SRPC <span class="anchor" id="line-273"></span></li><li><p class="line862">Test<strong></strong>Bit<strong></strong>Vector <span class="anchor" id="line-274"></span></li><li><p class="line862">Test<strong></strong>Compact<strong></strong>FV <span class="anchor" id="line-275"></span></li><li>TestPKPrefix <span class="anchor" id="line-276"></span></li><li><p class="line862">Test<strong></strong>Prefix<strong></strong>Tbl <span class="anchor" id="line-277"></span></li><li><p class="line862">Test<strong></strong>Timer <span class="anchor" id="line-278"></span></li><li><p class="line862">Test<strong></strong>Flush<strong></strong>Queue <span class="anchor" id="line-279"></span></li></ul></li><li>All programs in the perftools package: <span class="anchor" id="line-280"></span><ul><li><p class="line862">Count<strong></strong>Short<strong></strong>Ids <span class="anchor" id="line-281"></span></li><li><p class="line862">Short<strong></strong>Id<strong></strong>Set<strong></strong>Diff <span class="anchor" id="line-282"></span></li></ul></li><li>The test programs in the fp package: <span class="anchor" id="line-283"></span><ul><li>TestFP <span class="anchor" id="line-284"></span></li><li>TestFPPerf <span class="anchor" id="line-285"></span></li><li><p class="line862">Test<strong></strong>Unique<strong></strong>Id <span class="anchor" id="line-286"></span></li><li>TestFPTable <span class="anchor" id="line-287"></span></li></ul></li><li>The performance data analysis programs in the repos package: <span class="anchor" id="line-288"></span><ul><li>read_timing <span class="anchor" id="line-289"></span></li><li>read_lock_timing <span class="anchor" id="line-290"></span></li></ul></li><li>All programs in the weeder package: <span class="anchor" id="line-291"></span><ul><li><p class="line862">Vesta<strong></strong>Weed <span class="anchor" id="line-292"></span></li><li><p class="line862">Quick<strong></strong>Weed <span class="anchor" id="line-293"></span></li><li><p class="line862">Print<strong></strong>Weeder<strong></strong>Vars <span class="anchor" id="line-294"></span></li></ul></li><li>Some of the test programs in the basics package: <span class="anchor" id="line-295"></span><ul><li>TestTextGC <span class="anchor" id="line-296"></span></li><li>TestAllocatorGC <span class="anchor" id="line-297"></span></li></ul></li><li>Some of the test programs in the generics package: <span class="anchor" id="line-298"></span><ul><li><p class="line862">Test<strong></strong>Atom <span class="anchor" id="line-299"></span></li><li>TestIntSTbl <span class="anchor" id="line-300"></span></li></ul></ul><span class="anchor" id="bottom"></span></div>
<div id="pagebottom"></div>
</div>


<div id="footer">
<ul id="credits">
<li><a href="http://moinmo.in/" title="This site uses the MoinMoin Wiki software.">MoinMoin Powered</a></li><li><a href="http://moinmo.in/Python" title="MoinMoin is written in Python.">Python Powered</a></li><li><a href="http://moinmo.in/GPL" title="MoinMoin is GPL licensed.">GPL licensed</a></li><li><a href="http://validator.w3.org/check?uri=referer" title="Click here to validate this page.">Valid HTML 4.01</a></li>
</ul>


</div>
</body>
</html>

